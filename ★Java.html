<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>WEB_Java</title>
</head>

<link rel="stylesheet" href="CSS_Style.css">

<body>
  <h1 id="mainhead">Java</h1>
  <div class="grid">
    <div class="gridleft">
      <ul>
        <a href="★WEB.html">
          <li>WEB</li>
        </a>
        <ol>
          <a href="★HTML.html">
            <li>HTML</li>
          </a>
          <a href="★CSS.html">
            <li>CSS</li>
          </a>
          <a href="★JavaScript.html">
            <li>JavaScript</li>
          </a>
          <a href="★Java.html">
            <li id="active">Java</li>
          </a>
        </ol>
        <a href="★C.html">
          <li>C언어</li>
        </a>
        <a href="★Linux.html">
          <li>Linux</li>
        </a>
      </ul>

      <br>
      <input id="Plan2" type="button" value="Study Plan" onclick="location.href = '★Plan_java.html' ">
    </div>

    <div class="gridright">
      <h1>Java : 객체 지향 프로그래밍 언어</h1>
      <h2>Compile & Run</h2>
      <p>소스코드파일(.java)은 컴파일러(javac.exe)를 통해 컴파일되어
        <br>바이트코드파일(.class)이 생성되고 JVM(java.exe)을 통해 각 운영체제에서 실행된다.
        <br><img src="Java_JVM.jpg" width="500px" border="1">
      </p>


      <h1>Data</h1>
      <h2>Data Type</h2>
      <table border="1">
        <thead>
          <tr>
            <th>정수</th>
            <th>Byte</th>
            <th>범위</th>
          </tr>
        </thead>
        <tr>
          <td>byte</td>
          <td>1</td>
          <td>-2⁷ ~ (2⁷-1) (-128 ~ 127)</td>
        </tr>
        <tr>
          <td>char(문자)</td>
          <td>2</td>
          <td>0 ~ (2¹⁶-1) (0 ~ 65,535) 유니코드 \u0000 ~ \uFFFF **unsgined</td>
        </tr>
        <tr>
          <td>short</td>
          <td>2</td>
          <td>-2¹⁵ ~ (2¹⁵-1) (-32,768 ~ 32,767)</td>
        </tr>
        <tr>
          <td>int</td>
          <td>4</td>
          <td>-2³¹ ~ (2³¹-1) (-2,147,483,648 ~ 2,147,483,647)</td>
        </tr>
        <tr>
          <td>long</td>
          <td>8</td>
          <td>-2⁶³ ~ (2⁶³-1) (-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807)</td>
        </tr>
        <thead>
          <tr>
            <th>실수</th>
            <th>Byte</th>
            <th>범위</th>
          </tr>
        </thead>
        <tr>
          <td>float</td>
          <td>4</td>
          <td>0x0.000002P-126f ~ 0x1.FFFFFeP+127f</td>
        </tr>
        <tr>
          <td>double</td>
          <td>8</td>
          <td>0x0.0000000000001P-1022 ~ 0x1.FFFFFFFFFFFFfP+1023 </td>
        </tr>
        <thead>
          <tr>
            <th>논리</th>
            <th>Bit</th>
            <th>범위</th>
          </tr>
        </thead>
        <tr>
          <td>boolean</td>
          <td>1bit</td>
          <td>true / false</td>
        </tr>
      </table>
      <ul>
        <li><span id="accent">정수 </span>는 최상위비트 1bit가 부호정보를 저장하기 때문에 자료형 byte크기에서 1bit를 뺀 수의 제곱으로 표현 범위를 구할 수 있다. 만약 최상위비트가 1이라면 음의 정수이고, 십진수로 나타내려면 나머지 bit를 보수로 역전시킨 뒤 1을 더한 값에 -를 붙이면 된다.
        <br>정확한 최대와
          최소는 Integer.MAX_VALUE; </li>
        <li><span id="accent">실수 </span><span id="question">범위가 왜 저렇게 나오지??</span></li>
        <li><span id="accent">문자 </span> 자료형 char는 java에서 unsgined로 동작 하므로 부호없이 2byte 모두 uni code로 쓰인다.</li>
        <li><span id="accent">논리 </span> 자료형 boolean은 1bit 이다 <span id="comment">Java에서는 boolean을 0과 1로 표기하지않음</span></li>
      </ul>
      <ul><span id="ulh">etc</span>
        <li>"H" <span id="accent"> →1글자지만 String</span></li>
        <li>"6"+"6" <span id="comment"> →66</span></li>
        <li>"6"*"6" <span id="comment"> →문자열 *연산 불가</span></li>
        <li>"1111".length(); <span id="comment"> →문자열 길이는 4</span></li>
        <li>1111.length(); <span id="comment"> →Error</span></li>
      </ul>

      <h2>Variable</h2>
      <p>변수란 하나의 값을 저장할 수 있는 메모리 공간이다
      <br> 변수는 선언된 { } 블록내에서만 사용 가능하다</p>
      <ul><span id="ulh">변수 명명 규칙</span>
        <li>첫 번재 글자는 문자이거나, '$' '_' 이어야 하고 숫자로 시작할 수 없다(필수)</li>
        <li>영어 대소문자가 구분된다(필수)</li>
        <li>첫 문자는 영어 소문자로 시작하되, 다른 단어가 붙을 경우 첫 문자를 대문자로 한다(관례)</li>
        <li>문자 길이의 제한은 없다</li>
        <li>자바 예약어(int, public, new, true, if 등) 는 사용할 수 없다(필수)</li>
      </ul>

      <h3>Constant</h3>
      <p>상수는 선언과 동시에 초기화를 해야하며, 이후 변경이 불가하다.
        <br><span id="comment">상수를 선언하는 방법 : final int x = 10;</span>
      </p>

      <h3>Literal</h3>
      <p>리터럴은 값 그 자체이다.
        <br>정수 리터럴은 기본 int(4byte)이고, long 타입은 뒤에 l 또는 L을 추가
        <br>실수 리터럴은 기본 double(8yte)이고, float 타입은 뒤에 f 또는 F를 추가
        <br>문자 리터럴은 기본적으로 char(2byte)이고, 문자열 리터럴은 기본적으로 String
      </p>

      <h2>Casting</h2>
      <p>형 변환이란 변수나 리터럴의 타입을 다른 타입으로 변환하는 것이다.</p>
      <ul>
        <li><span id="accent">묵시적 형 변환 </span>작은타입 → 큰타입으로 변환할 때는 자동으로 형 변환된다. <br>리터럴은 변수 저장시 해당 변수타입에 저장할 수 있는 범위만 넘지 않으면
          자동 형 변환된다.</li>
        <li><span id="accent">명시적 형 변환 </span>큰타입 → 작은타입으로 변환할 때는 ( )로 강제 형 변환 하여야한다. <br>이때 데이터 손실이나 오버플로우가 발생 할 수 있다.
          <span id="comment">int num10 = (int) 3.14; 이때 0.14 값은 손실된다.</span></li>
      </ul>
      <ul><span id="ulh">etc</span>
        <li>System.out.println((int) ch1); <span id="comment"> →char를 int로 형변환하여 유니코드값 출력</span></li>
        <li>System.out.println(변수.getClass()); <span id="comment"> →변수의 자료형 출력</span></li>
      </ul>

      <h2>Primitive & Reference</h2>
      <p><img src="Java_data.jpg" width="500px" border="1"></p>
      <ul><span id="ulh">Primitive Type</span>
        <li><span id="accent">원시자료형, 더이상 쪼개어지지않음</span></li>
        <li><span id="comment">8가지 : boolean, byte, short, int, long, char, float, double</span></li>
        <li>기본값이 있기 때문에 Null이 존재하지 않는다</li>
        <li>실제 값을 저장하는 공간으로 스택(Stack) 메모리에 저장</li>
      </ul>
      <ul><span id="ulh">Reference Type</span>
        <li><span id="accent">원시자료형을 제외한 모든 타입은 참조자료형, 객체(Object)의 주소를 참조한다.</span></li>
        <li><span id="comment">Class(String), Interface, Enum, Array</span></li>
        <li>빈 객체를 의미하는 Null이 기본값이다</li>
        <li>힙(Heap)영역에 생성된 객체의 주소값이 스택(Stack)영역에 참조자료형으로 저장된다. 즉 스택에는 참조값만 있고 실제값은 힙에 존재한다</li>
      </ul>
      <h3>== & equals()</h3>
      <p><img src="Java_equals.jpg" width="600px" border="1"></p>
      <ul>
        <li>==는 같은 데이터를 가리키는지 확인하는 연산자이고 (Primitive type에 사용)</li>
        <li>equals()는 담긴 데이터가 같은지 비교하는 메소드이다 (Reference type에 사용)</li>
        <li>java에서 문자열처럼 객체를 비교할 때는 equals()를 사용해야 한다 (String만 예외로 ==가 동작하기도 한다)</li>
      </ul>

      <h2>Print & Scanner</h2>
      <h3>Print</h3>
      <ul>
        <li><span id="accent">System.out.println(); </span> 출력 후 개행</li>
        <li><span id="accent">System.out.print(); </span> 개행없이 출력</li>
        <li><span id="accent">System.out.printf(); </span> 변수의 값을 지시자 형식으로 변환하여 출력</li>
 
      </ul>
      <ul><span id="ulh">etc</span>
        <li>System.out.println("Hello \"World\""); <span id="comment"> →escape</span></li>
        <li>System.out.println("Hello <span id="accent"> →줄바꿈 불가능</span>
          <br>World");
        </li>
        <li>System.out.println("Hello " <span id="comment"> →OK</span>
          <br>+ "World");
        </li>
        <li>System.out.printf("&.3f", 변수) <span id="comment"> →소수점 셋째자리까지 출력</span></li>
      </ul>
      <h3>Scanner</h3>
      <ul>
        <li><span id="accent">sc.nextInt(); </span> 정수 입력받기</li>
        <li><span id="accent">sc.nextLine(); </span> Enter전까지 입력받은 문자열을 리턴 <span id="comment">*엔터버퍼 주의*</span></li>
        <li><span id="accent">sc.next(); </span> Space전까지 입력받은 문자열을 리턴</li>
        <li><span id="accent">sc.next().charAt(0); </span> 입력받은 문자열중 첫번째 문자만 저장</li>
      </ul>

      <h1>Operator</h1>
      <h2>단항 연산자</h2>
      <h3>증감 연산자 (++ --)</h3>
      <p>변수의 값을 1 증가 또는 감소할 때 사용하는 연산자. 변수의 앞(prefix)과 뒤(suffix)에 사용 (x++ 또는 --x), boolean 타입을 제외한 모든 기본 타입의 피연산자에 사용가능
      <br>증감 연산자가 단독으로 사용되는 경우 전위 후위 모두 동일한 결과이나, 다른 연산자와 함께 사용되는 경우 차이 발생 <span id="accent">섞어쓰지말고 x++만 쓰자</span>
      </p>
      <ul><span id=ulh>전위 후위 연산 비교</span>
        <li>result = num++ + 5; <span id="comment"> →num + 5가 먼저 실행되고 result에 값을 저장한 뒤, num을 1 증가</span></li>
        <li>result = ++num + 5; <span id="comment"> →++num이 먼저 실행되고, num + 5의 값이 result에 저장</span></li>
        <li>result = num++ + 5 + ++num; <span id="comment"> →num + 5 연산, num++되어 num에 저장, ++num이 실행, 최종적으로 2증가한 num이
            더해짐</span></li>
      </ul>

      <h3>논리 부정 연산자 (!)</h3>
      <p>true를 false로, false를 true로 변경. boolean 타입에만 사용가능</p>

      <h2>이항 연산자</h2>
      <h3>대입연산자 (=)</h3>
      <p>오른쪽의 값을 왼쪽의 변수에 저장하는 연산자. 변수 = 값;</p>

      <h3>복합 대입 연산자 (+= -= *= %=)</h3>

      <h3>산술연산자 (+ - * / %)</h3>
      <p>boolean 타입을 제외한 모든 기본 타입에 사용</p>
      <ul><span id=ulh>산술변환 (산술연산시 자료형 주의)</span>
        <li>두 피연산자 자료형 중 더 큰 자료형으로 일치시키거나 (값손실을 최소화)</li>
        <li><span id="accent"> 두 피연산자 모두 int보다 작을 때(byte, char, short)는 int로 변환시킨다</span> (연산시 오버플로우 가능성이 높기 때문에)</li>
      </ul>

      <ul><span id=ulh>정수와 실수의 산술연산</span>
        <li>5 / 2 = 2</li>
        <li>5 / 2.0 = 2.5 <span id="comment"> →실수/실수, 실수/정수, 정수/실수 : 소수점까지 계산</span></li>
        <li>System.out.println(246/0);<span id="comment"> →정수 0으로 나누는 것은 불가능하기 때문에 Exception발생</span></li>
        <li>System.out.println(246/0.0);<span id="comment"> →실수 0.0으로 나누면 Infinity</span> <span id="question">왜?? 0.0은 뒤에 소수점땜에 완전한 0이 아닌가?</span></li>
      </ul>

      <h3>비교 연산자 (&lt; > &lt;= >= == !=)</h3>
      <p>대소 연산자는 boolean을 제외한 기본 타입에 사용할 수 있고, 동등 연산자는 모든 타입에 사용가능, 연산 결과로 true/false를 리턴</p>

      <h3>논리 연산자 (&& || !)</h3>
      <p>boolean 타입의 변수를 사용하여 연산, 결과로 true/false를 리턴</p>
      <ul><span id=ulh>SCE (Short-circuit evaluation : Lazy Evaluation)</span>
        <li>A && B 를 계산할 때 A가 false이면, B를 계산하지 않음 <span id="comment"> →B는 Dead code</span></li>
        <li>A || B 를 계산할 때 A가 true이면, B를 계산하지 않음</li>
      </ul>

      <h1>Flow Control</h1>
      <p>프로그램의 실행 흐름을 원하는 방향으로 바꾸는 제어문. 제어문에는 조건문과 반복문이 있다.</p>
      <h2>Conditional statement</h2>
      <h3>if</h3>
      <ul>
        <li>if</li>
        <li>if - else</li>
        <li>if - else if - else <span id="comment">else if는 위의 조건식을 제외한 나머지영역에서 조건 검사를 한다</span></li>
      </ul>
      <p><span id ="comment"> if 중첩문은 else if로 바꿀 수 있는지 확인하기</span></p>
      <h3>switch</h3>
      <p>if문은 경우의 수가 많을때 조건식을 계산 처리하는 시간이 많이 걸린다 switch문은 단 하나의 표현식으로 많은 경우의 수를 처리하기 용이하다 <span id="comment">switch조건은 ==일치 연산만 가능</span>
      </p>
      <ul>
        <li>switch (변수) {
      <br>&nbsp;&nbsp; case 값1 :
      <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 코드
      <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
      <br>&nbsp;&nbsp; case 값2 :
      <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 코드
      <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
      <br>&nbsp;&nbsp; default :
      <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 코드
      <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
      <br> }
      </li>
      </ul>
      <p><span id="comment">case가 선택된순간 다른 case는 꺼지고 다음 break를 만나기 전까지의 코드가 실행된다. 예를들어 case 1: case 2: case 3: 코드; break; 에서 조건이 2일때 case 3은 꺼지고 다음 코드가 실행되고 break된다</span></p>
      <h2>Loops and iteration</h2>
      <h3>for</h3>
      <ul>
        <li>for (초기식; 조건식; 증감식) { 코드 }</li>
        <li>실행순서 1.초기식 2.조건식 3.본문 4.증감식</li>
        <li>증감식에는 ++뿐 아니라, 다양한 식을 활용할 수 있다</li>
      </ul>
      <h3>while</h3>
      <ul>
        <li>while (조건식) { 코드 }</li>
      </ul>
      <h3>do - while</h3>
      <ul>
        <li>do { 코드 } while (조건)</li>
        <li><span id="comment">무조건 한 번 본문을 실행한 후 반복문의 조건에 따라 반복 실행</span></li>
      </ul>
      <h3>break & continue</h3>
      <ul>
        <li><span id="accent">break;가 포함된 가장 가까움 반복문 { }을 자체를 탈출하고 종료</span></li>
        <li><span id="accent">continue;는 아래 명령을 실행하지 않고, 반복문의 조건식으로 돌아가 다음 반복문 절차를 수행</span></li>
        <li>while (true) 무한루프와 if를 함께 사용한다</li>
      </ul>
      <h3>for - each</h3>
      <ul>
        <li>for-each문 (향상된 for문) : 배열에 있는 모든 테이터를 접근할 때 사용</li>
        <li>for (타입 변수이름 : 배열) { ... }</li>
        <li><span id="comment">0번째부터 끝까지 접근하며 거꾸로 불가, 인덱스없이 변수에 계속 바꿔담으면서 접근, 배열에 값을 담는 것은 불가</span></li>
      </ul>

      <h1>Array</h1>
      <p>배열은 '같은 타입'의 여러 변수를 하나의 묶음으로 저장할 때 사용</p>
      <h2>선언과 생성</h2>
      <ul>
        <li><span id="accent">타입[ ] 배열이름;</span> 선언 : 배열을 다루기 위한 참조변수(배열이름)를 Stack 영역에 생성 (%s로 참조값 확인가능, default값은 null)</li>
        <li><span id="accent">배열이름 = new 타입[길이];</span> 생성 : 값을 저장할 실제 저장공간을 Heap 영역에 생성</li>
        <li>즉, 배열은 Heap영역의 값을 참조하는 Reference Type이다.</li>
        <li>배열 생성시 길이 생략불가. 길이 메소드 array.length;</li>
      </ul>

      <h2>초기화</h2>
      <p>배열은 생성과 동시에 자동적으로 해당타입의 default값으로 초기화된다. <br>그러나 원하는 값으로 지정하여 초기화도 가능하다</p>
      <ul><span id="ulh">선언 후 초기화</span>
        <li>선언 : int[] array = new int[길이];</li>
        <li>초기화 : array[index] = 값; <span id="comment">초기화란 처음 값을 넣는 것</span></li>
      </ul>
      <ul><span id="ulh">선언과 초기화 동시</span>
        <li>int[] array = { 값1, 값2, ...};</li>
        <li>int[] array = new int[] { 값1, 값2, ...}</li>
      </ul>
      <ul><span id="ulh"></span>
        <li>int[] array;<br>
        array = new int[] { 값1, 값2, 값3,,,}; <span id="comment">→변수선언과 생성을 따로하는 경우 new 생략불가</span></li>
      </ul>

      <h2>2차원 배열</h2>
      <p>1차원 배열을 원소로 갖는 배열</p>
      <ul>
        <li><span id="accent">타입[행][열] 변수이름;</span></li>
        <li><span id="accent">타입 변수이름[행][열];</span></li>
        <li><span id="accent">타입[행] 변수이름[열];</span></li>
      </ul>
      <ul>
        <li><span id="accent">array.length</span> 행의 갯수</li>
        <li><span id="accent">array[index].length</span> 지정 열의 갯수</li>
      </ul>

      <h1>Method</h1>
      <p>메소드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것
<br>어떤 값을 입력하면 이 값으로 작업을 수행해서 결과를 반환</p>

    </div>
  </div>
</body>

</html>