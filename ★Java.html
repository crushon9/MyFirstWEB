<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>WEB_Java</title>
</head>

<link rel="stylesheet" href="CSS_Style.css">

<body>
  <h1 id="mainhead">Java</h1>
  <div class="grid">
    <div class="gridleft">
      <ul>
        <a href="★WEB.html">
          <li>WEB</li>
        </a>
        <ol>
          <a href="★HTML.html">
            <li>HTML</li>
          </a>
          <a href="★CSS.html">
            <li>CSS</li>
          </a>
          <a href="★JavaScript.html">
            <li>JavaScript</li>
          </a>
          <a href="★Java.html">
            <li id="active">Java</li>
          </a>
        </ol>
        <a href="★C.html">
          <li>C언어</li>
        </a>
        <a href="★Linux.html">
          <li>Linux</li>
        </a>
      </ul>

      <br>
      <input id="Plan2" type="button" value="Study Plan" onclick="location.href = '★Plan_java.html' ">
    </div>

    <div class="gridright">
      <h1>Java : 객체 지향 프로그래밍 언어</h1>
      <h2>Compile & Run</h2>
      <p>소스코드파일(.java)은 컴파일러(javac.exe)를 통해 컴파일되어
        <br>바이트코드파일(.class)이 생성되고 JVM(java.exe)을 통해 각 운영체제에서 실행된다.
        <br><img src="Java_JVM.jpg" width="500px" border="1">
      </p>


      <h1>Data</h1>
      <h2>Data Type</h2>
      <table border="1">
        <thead>
          <tr>
            <th>정수</th>
            <th>Byte</th>
            <th>범위</th>
          </tr>
        </thead>
        <tr>
          <td>byte</td>
          <td>1</td>
          <td>-2⁷ ~ 2⁷-1 (-128 ~ 127)</td>
        </tr>
        <tr>
          <td>short</td>
          <td>2</td>
          <td>-2¹⁵ ~ 2¹⁵-1 (-32,768 ~ 32,767)</td>
        </tr>
        <tr>
          <td>int</td>
          <td>4</td>
          <td>-2³¹ ~ 2³¹-1 (-2,147,483,648 ~ 2,147,483,647)</td>
        </tr>
        <tr>
          <td>long</td>
          <td>8</td>
          <td>-2⁶³ ~ 2⁶³-1 (-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807)</td>
        </tr>
        <thead>
          <tr>
            <th>실수</th>
            <th>Byte</th>
            <th>범위</th>
          </tr>
        </thead>
        <tr>
          <td>float</td>
          <td>4</td>
          <td>0x0.000002P-126f ~ 0x1.FFFFFeP+127f</td>
        </tr>
        <tr>
          <td>double</td>
          <td>8</td>
          <td>0x0.0000000000001P-1022 ~ 0x1.FFFFFFFFFFFFfP+1023 </td>
        </tr>
        <thead>
          <tr>
            <th>문자</th>
            <th>Byte</th>
            <th>범위</th>
          </tr>
        </thead>
        <tr>
          <td>char</td>
          <td>2</td>
          <td>0 ~ 2¹⁶-1 (65,535) 유니코드 \u0000 ~ \uFFFF **unsgined</td>
        </tr>
        <thead>
          <tr>
            <th>논리</th>
            <th>Bit</th>
            <th>범위</th>
          </tr>
        </thead>
        <tr>
          <td>boolean</td>
          <td>1bit</td>
          <td>true / false</td>
        </tr>
      </table>
      <ul>
        <li><span id="accent">정수 </span>는 1bit가 부호정보를 저장하기 때문에 자료형 byte크기에서 1bit를 뺀 수의 제곱으로 표현 범위를 구할 수 있다. 각 타입의 정확한 최대와
          최소는 Integer.MIN_VALUE;</li>
        <li><span id="accent">실수 </span><span id="question">범위가 왜 저렇게 나오지??</span></li>
        <li><span id="accent">문자 </span> 자료형 char는 java에서 unsgined로 동작 하므로 부호없이 2byte 모두 uni code로 쓰인다.</li>
        <li><span id="accent">논리 </span> 자료형 boolean은 1bit 이다 <span id="comment">Java에서는 boolean을 0과 1로 표기하지않음</span></li>
      </ul>
      <ul><span id="ulh">etc</span>
        <li>"H" <span id="accent"> →1글자지만 String</span></li>
        <li>"6"+"6" <span id="comment"> →66</span></li>
        <li>"6"*"6" <span id="comment"> →문자열 *연산 불가</span></li>
        <li>"1111".length(); <span id="comment"> →문자열 길이는 4</span></li>
        <li>1111.length(); <span id="comment"> →Error</span></li>
      </ul>

      <h2>Variable</h2>
      <p>변수란 하나의 값을 저장할 수 있는 메모리 공간이다</p>

      <h3>Constant</h3>
      <p>상수는 선언과 동시에 초기화를 해야하며, 이후 변경이 불가하다.
        <br><span id="comment">상수를 선언하는 방법 : final int x = 10;</span>
      </p>

      <h3>Literal</h3>
      <p>리터럴은 값 그 자체이다.
        <br>정수 리터럴은 기본 int(4byte)이고, long 타입은 뒤에 l 또는 L을 추가
        <br>실수 리터럴은 기본 double(8yte)이고, float 타입은 뒤에 f 또는 F를 추가
        <br>문자 리터럴은 기본적으로 char(2byte)이고, 문자열 리터럴은 기본적으로 String
      </p>

      <h2>Casting</h2>
      <p>형 변환이란 변수나 리터럴의 타입을 다른 타입으로 변환하는 것이다.</p>
      <ul>
        <li><span id="accent">묵시적 형 변환 </span>작은타입 → 큰타입으로 변환할 때는 자동으로 형 변환된다. <br>리터럴은 변수 저장시 해당 변수타입에 저장할 수 있는 범위만 넘지 않으면
          자동 형 변환된다.</li>
        <li><span id="accent">명시적 형 변환 </span>큰타입 → 작은타입으로 변환할 때는 ( )로 강제 형 변환 하여야한다. <br>이때 데이터 손실이나 오버플로우가 발생 할 수 있다.
          <span id="comment">int num10 = (int) 3.14; 이때 0.14 값은 손실된다.</span></li>
      </ul>
      <ul><span id="ulh">etc</span>
        <li>System.out.println((int) ch1); <span id="comment"> →char를 int로 형변환하여 유니코드값 출력</span></li>
        <li>System.out.println(변수.getClass()); <span id="comment"> →변수의 자료형 출력</span></li>
      </ul>

      <h2>Primitive & Reference</h2>
      <p><img src="Java_data.jpg" width="500px" border="1"></p>
      <ul><span id="ulh">Primitive Type</span>
        <li><span id="accent">원시자료형, 더이상 쪼개어지지않음</span></li>
        <li><span id="comment">8가지 : boolean, byte, short, int, long, char, float, double</span></li>
        <li>기본값이 있기 때문에 Null이 존재하지 않는다</li>
        <li>실제 값을 저장하는 공간으로 스택(Stack) 메모리에 저장</li>
      </ul>
      <ul><span id="ulh">Reference Type</span>
        <li><span id="accent">원시자료형을 제외한 모든 타입은 참조자료형, 객체(Object)의 주소를 참조한다.</span></li>
        <li><span id="comment">Class(String), Interface, Enum, Array</span></li>
        <li>빈 객체를 의미하는 Null이 기본값이다</li>
        <li>힙(Heap)영역에 생성된 객체의 주소값이 스택(Stack)영역에 참조자료형으로 저장된다. 즉 스택에는 참조값만 있고 실제값은 힙에 존재한다</li>
      </ul>
      <h3>== & equals()</h3>
      <p><img src="Java_equals.jpg" width="600px" border="1"></p>
      <ul>
        <li>==는 같은 데이터를 가리키는지 확인하는 연산자이고 (Primitive type에 사용)</li>
        <li>equals()는 담긴 데이터가 같은지 비교하는 메소드이다 (Reference type에 사용)</li>
        <li>java에서 문자열처럼 객체를 비교할 때는 equals()를 사용해야 한다 (String만 예외로 ==가 동작하기도 한다)</li>
      </ul>

      <h2>Print & Scanner</h2>
      <h3>Print</h3>
      <ul>
        <li><span id="accent">System.out.println(); </span> 출력 후 개행</li>
        <li><span id="accent">System.out.print(); </span> 개행없이 출력</li>
        <li><span id="accent">System.out.printf(); </span> 변수의 값을 지시자 형식으로 변환하여 출력</li>
 
      </ul>
      <ul><span id="ulh">etc</span>
        <li>System.out.println("Hello \"World\""); <span id="comment"> →escape</span></li>
        <li>System.out.println("Hello <span id="accent"> →줄바꿈 불가능</span>
          <br>World");
        </li>
        <li>System.out.println("Hello " <span id="comment"> →OK</span>
          <br>+ "World");
        </li>
        <li>System.out.printf("&.3f", 변수) <span id="comment"> →소수점 셋째자리까지 출력</span></li>
      </ul>
      <h3>Scanner</h3>
      <ul>
        <li><span id="accent">sc.nextInt(); </span> 정수 입력받기</li>
        <li><span id="accent">sc.nextLine(); </span> Enter전까지 입력받은 문자열을 리턴 <span id="comment">*엔터버퍼 주의*</span></li>
        <li><span id="accent">sc.next(); </span> Space전까지 입력받은 문자열을 리턴</li>
        <li><span id="accent">sc.next().charAt(0); </span> 입력받은 문자열중 첫번째 문자만 저장</li>
      </ul>

      <h1>Operator</h1>
      <h2>단항 연산자</h2>
      <h3>증감 연산자 (++ --)</h3>
      <p>변수의 값을 1 증가 또는 감소할 때 사용하는 연산자. 변수의 앞(prefix)과 뒤(suffix)에 사용 (x++ 또는 --x), boolean 타입을 제외한 모든 기본 타입의 피연산자에 사용가능
      <br>증감 연산자가 단독으로 사용되는 경우 전위 후위 모두 동일한 결과이나, 다른 연산자와 함께 사용되는 경우 차이 발생 <span id="accent">섞어쓰지말고 x++만 쓰자</span>
      </p>
      <ul><span id=ulh>전위 후위 연산 비교</span>
        <li>result = num++ + 5; <span id="comment"> →num + 5가 먼저 실행되고 result에 값을 저장한 뒤, num을 1 증가</span></li>
        <li>result = ++num + 5; <span id="comment"> →++num이 먼저 실행되고, num + 5의 값이 result에 저장</span></li>
        <li>result = num++ + 5 + ++num; <span id="comment"> →num + 5 연산, num++되어 num에 저장, ++num이 실행, 최종적으로 2증가한 num이
            더해짐</span></li>
      </ul>

      <h3>논리 부정 연산자 (!)</h3>
      <p>true를 false로, false를 true로 변경. boolean 타입에만 사용가능</p>

      <h2>이항 연산자</h2>
      <h3>대입연산자 (=)</h3>
      <p>오른쪽의 값을 왼쪽의 변수에 저장하는 연산자. 변수 = 값;</p>

      <h3>복합 대입 연산자 (+= -= *= %=)</h3>

      <h3>산술연산자 (+ - * / %)</h3>
      <p>boolean 타입을 제외한 모든 기본 타입에 사용</p>
      <ul><span id=ulh>산술변환 (산술연산시 자료형 주의)</span>
        <li>두 피연산자 자료형 중 더 큰 자료형으로 일치시키거나 (값손실을 최소화)</li>
        <li><span id="accent"> 두 피연산자 모두 int보다 작을 때(byte, char, short)는 int로 변환시킨다</span> (연산시 오버플로우 가능성이 높기 때문에)</li>
      </ul>

      <ul><span id=ulh>정수와 실수의 산술연산</span>
        <li>5 / 2 = 2</li>
        <li>5 / 2.0 = 2.5 <span id="comment"> →실수/실수, 실수/정수, 정수/실수 : 소수점까지 계산</span></li>
        <li>System.out.println(246/0);<span id="comment"> →정수 0으로 나누는 것은 불가능하기 때문에 Exception발생</span></li>
        <li>System.out.println(246/0.0);<span id="comment"> →실수 0.0으로 나누면 Infinity</span> <span id="question">왜?? 0.0은 뒤에 소수점땜에 완전한 0이 아닌가?</span></li>
      </ul>

      <h3>비교 연산자 (< > <= >= == !=)</h3>
      <p>대소 연산자는 boolean을 제외한 기본 타입에 사용할 수 있고, 동등 연산자는 모든 타입에 사용가능, 연산 결과로 true/false를 리턴</p>

      <h3>논리 연산자 (&& || !)</h3>
      <p>boolean 타입의 변수를 사용하여 연산, 결과로 true/false를 리턴</p>
      <ul><span id=ulh>SCE (Short-circuit evaluation : Lazy Evaluation)</span>
        <li>A && B 를 계산할 때 A가 false이면, B를 계산하지 않음 <span id="comment"> →B는 Dead code</span></li>
        <li>A || B 를 계산할 때 A가 true이면, B를 계산하지 않음</li>
      </ul>

      <h1>Flow Control</h1>
      if 중첩문은 아래의 else if와 논리적으로 같은 코드!!

    </div>
  </div>
</body>

</html>