<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>WEB_Java</title>
</head>

<link rel="stylesheet" href="CSS_Style.css">

<body>
  <h1 id="mainhead">Java</h1>
  <div class="grid">
    <div class="gridleft">
      <ul>
        <a href="★WEB.html">
          <li>WEB</li>
        </a>
        <ol>
          <a href="★HTML.html">
            <li>HTML</li>
          </a>
          <a href="★CSS.html">
            <li>CSS</li>
          </a>
          <a href="★JavaScript.html">
            <li>JavaScript</li>
          </a>
          <a href="★Java.html">
            <li id="active">Java</li>
          </a>
        </ol>
        <a href="★C.html">
          <li>C언어</li>
        </a>
        <a href="★Linux.html">
          <li>Linux</li>
        </a>
      </ul>

      <br>
      <input id="Plan2" type="button" value="Study Plan" onclick="location.href = '★Plan_java.html' ">
    </div>

    <div class="gridright">
      <h1>Java : 객체 지향 프로그래밍 언어</h1>
      <h2>Compile & Run</h2>
      <p>소스코드파일(.java)은 컴파일러(javac.exe)를 통해 컴파일되어
        <br>바이트코드파일(.class)이 생성되고 JVM(java.exe)을 통해 각 운영체제에서 실행된다.
        <br><img src="Java_JVM.jpg" width="500px" border="1">
        <ul><span id="ulh">터미널에서 컴파일하기</span>
          <li>javac 소스코드.java <span id="comment"> →class파일생성, 같은 디렉토리의 import파일 자동 컴파일</span>
          <br>javac -cp ".:경로" 소스코드.java <span id="comment"> →다른 디렉토리의 import파일 명시 --class--path
          <br>. (=현재디렉토리) : (=연결구분자) 경로</span></li>
          <li>java class파일이름 <span id="comment"> →주의 .class를 붙이지않음</span></li>
        </ul>
      </p>


      <h1>Data</h1>
      <h2>Data Type</h2>
      <table border="1">
        <thead>
          <tr>
            <th>정수</th>
            <th>Byte</th>
            <th>범위</th>
          </tr>
        </thead>
        <tr>
          <td>byte</td>
          <td>1</td>
          <td>-2⁷ ~ (2⁷-1) (-128 ~ 127)</td>
        </tr>
        <tr>
          <td>char(문자)</td>
          <td>2</td>
          <td>0 ~ (2¹⁶-1) (0 ~ 65,535) 유니코드 \u0000 ~ \uFFFF **unsgined</td>
        </tr>
        <tr>
          <td>short</td>
          <td>2</td>
          <td>-2¹⁵ ~ (2¹⁵-1) (-32,768 ~ 32,767)</td>
        </tr>
        <tr>
          <td>int</td>
          <td>4</td>
          <td>-2³¹ ~ (2³¹-1) (-2,147,483,648 ~ 2,147,483,647)</td>
        </tr>
        <tr>
          <td>long</td>
          <td>8</td>
          <td>-2⁶³ ~ (2⁶³-1) (-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807)</td>
        </tr>
        <thead>
          <tr>
            <th>실수</th>
            <th>Byte</th>
            <th>범위</th>
          </tr>
        </thead>
        <tr>
          <td>float</td>
          <td>4</td>
          <td>0x0.000002P-126f ~ 0x1.FFFFFeP+127f</td>
        </tr>
        <tr>
          <td>double</td>
          <td>8</td>
          <td>0x0.0000000000001P-1022 ~ 0x1.FFFFFFFFFFFFfP+1023 </td>
        </tr>
        <thead>
          <tr>
            <th>논리</th>
            <th>Byte</th>
            <th>범위</th>
          </tr>
        </thead>
        <tr>
          <td>boolean</td>
          <td>1</td>
          <td>true / false</td>
        </tr>
      </table>
      <ul>
        <li><span id="accent">정수 : </span>최상위비트 1bit가 부호정보를 저장하기 때문에 자료형 byte크기에서 1bit를 뺀 수의 제곱으로 표현 범위를 구할 수 있다. 만약 최상위비트가 1이라면 음의 정수이고, 십진수로 나타내려면 나머지 bit를 보수로 역전시킨 뒤 1을 더한 값에 -를 붙이면 된다.
        <br>최대/최소값 : 타입명.MAX_VALUE; </li>
        <li><span id="accent">실수 : </span> 부동소수점 타입은 2진포맷가수를 사용하기 때문에 정확한 숫자가 아닌 근사값으로 표현된다 <span id="question">범위가 왜 저렇게 나오지??</span></li>
        <li><span id="accent">문자 : </span> char는 java에서 unsgined로 동작 하므로 부호없이 2byte 모두 uni code로 쓰인다.</li>
        <li><span id="accent">논리 : </span> boolean은 1byte로 true,false를 저장한다 <span id="comment">Java에서는 boolean을 0과 1로 표기하지않음</span></li>
      </ul>
      <ul><span id="ulh">etc</span>
        <li>"H" <span id="accent"> →1글자지만 String</span></li>
        <li>"6"+"6" <span id="comment"> →문자열 연결 연산 66</span></li>
        <li>Integer.toBinaryString <span id="comment"> →정수를 2진수 문자열로 리턴</span></li> 
      
      </ul>

      <h2>Variable</h2>
      <p>변수란 하나의 값을 저장할 수 있는 메모리 공간이다</p>

      <ul><span id="ulh">변수 작명 규칙</span>
        <li>첫 번재 글자는 문자이거나, '$' '_' 이어야 하고 숫자로 시작할 수 없다(필수)</li>
        <li>영어 대소문자가 구분된다(필수)</li>
        <li>첫 문자는 영어 소문자로 시작하되, 다른 단어가 붙을 경우 첫 문자를 대문자로 한다(관례)</li>
        <li>문자 길이의 제한은 없다</li>
        <li>자바 예약어(int, public, new, true, if 등) 는 사용할 수 없다(필수)</li>
      </ul>

      <h3>Literal</h3>
      <p>리터럴은 값 그 자체이다.
        <br>정수 리터럴은 기본 int(4byte)이고, long 타입은 뒤에 l 또는 L을 추가
        <br>실수 리터럴은 기본 double(8yte)이고, float 타입은 뒤에 f 또는 F를 추가
        <br>문자 리터럴은 기본적으로 char(2byte)이고, 문자열 리터럴은 기본적으로 String
      </p>

      <h2>Promotion & Casting</h2>
      <p>형 변환이란 변수나 리터럴의 타입을 다른 타입으로 변환하는 것이다.</p>
      <ul><span id="accent">자동(묵시적implicit) 타입 변환</span>
        <li>작은타입 → 큰타입</li>
        <li>리터럴은 변수 저장시 해당 변수타입 저장 범위를 넘지 않으면 자동 타입 변환된다.</li>
        <li><span id="comment">예외 : int → float 자동변환시 int값이 float의 가수 23bit로 표현가능한 범위를 넘을 경우 정밀도 손상이 일어난다</span></li>
        </ul>
      <ul><span id="accent">강제(명시적explicit) 타입 변환</span>
        <li>( )큰타입 → 작은타입</li>
        <li>( )로 명시하며, 데이터 손실이나 오버플로우가 발생 할 수 있다</li>
        <li><span id="comment">int num10 = (int) 3.14; 이때 0.14 값은 손실된다.</span></li>
      </ul>
      <ul><span id="ulh">etc</span>
        <li>System.out.println((int) ch1); <span id="comment"> →char를 int로 형변환하여 유니코드값 출력</span></li>
        <li>System.out.println(변수.getClass()); <span id="comment"> →변수의 자료형 출력</span></li>
      </ul>

      <h2>Runtime Data Area</h2>
      <p><img src="Java_memory.jpg" width="700px" border="1"></p>
      <ul><span id="ulh"></span>
        <li><span id="accent">Method 영역(static) : </span>static으로 선언한 변수, 메소드의 실행 코드들이 저장되는 메모리 영역. JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역</li>
        <li><span id="accent">Heap 영역 : </span> 인스턴스(참조 자료형)가 저장되는 메모리 영역. 참조되지않는 객체는 의미없으므로 Garbage collector가 자동으로 제거한다</li>
        <li><span id="accent">Stack 영역 : </span>지역 변수들이 저장되는 메모리 영역. 스택 영역은 각 스레드가 시작될 때 하나씩 할당된다. JVM 스택은 메소드를 호출할 때마다 flame을 push(추가)하고 종료되면 pop(제거)한다</li>
      </ul> 

      <h2>Primitive & Reference</h2>
      <p><img src="Java_data.jpg" width="500px" border="1"></p>
      <ul><span id="ulh">Primitive Type</span>
        <li><span id="accent">원시자료형, 더이상 쪼개어지지 않음</span></li>
        <li><span id="comment">8가지 : boolean, byte, short, int, long, char, float, double</span></li>
        <li>기본값이 있기 때문에 Null이 존재하지 않는다</li>
        <li>실제 값을 저장하는 공간으로 스택(Stack) 메모리에 저장</li>
      </ul>
      <ul><span id="ulh">Reference Type</span>
        <li><span id="accent">원시자료형을 제외한 모든 타입은 참조자료형, 객체(Object)의 주소를 참조한다.</span></li>
        <li><span id="comment">Class(String), Interface, Enum, Array</span></li>
        <li>빈 객체를 의미하는 Null이 기본값이다 (NullPointerException 발생주의)</li>
        <li>힙(Heap)영역에 생성된 객체의 주소값이 스택(Stack)영역에 참조자료형으로 저장된다. 즉 스택에는 참조값만 있고 실제값은 힙에 존재한다</li>
      </ul>
      <h3>== & equals()</h3>
      <p><img src="Java_equals.jpg" width="600px" border="1"></p>
      <ul>
        <li><span id="accent">==는 동일한 객체를 참조하는지 확인하는 연산자이고</span></li>
        <li><span id="accent">equals()는 담긴 데이터값이 동일한지 비교하는 메소드이다</span></li>
        <li>java에서 문자열 리터럴이 동일하다면 동일한 문자열 객체를 참조한다 <span id="comment"> ==:true equals():true</span>
        <br>하지만 new로 생성한 새로운 String은 다른 번지를 가지게된다<span id="comment"> ==:false equals():true</span></li>
      </ul>
      <h3>Call by</h3>
      <ul>
        <li>call by value : 값을 넘겨서 해당 값을 저장하여 작업</li>
        <li>call by reference : 주소값을 전달하기 때문에 어느 위치에서든 같은 객체 (메소드로 리턴값으로 주고받지않아도 원본값이 수정됨)</li>
      </ul>

      <h2>Print & Scanner</h2>
      <h3>Print</h3>
      <ul>
        <li><span id="accent">System.out.println(); </span> 출력 후 개행</li>
        <li><span id="accent">System.out.print(); </span> 개행없이 출력</li>
        <li><span id="accent">System.out.printf(); </span> 변수의 값을 지시자 형식으로 변환하여 출력</li>
 
      </ul>
      <ul><span id="ulh">etc</span>
        <li>System.out.println("Hello \"World\""); <span id="comment"> →escape</span></li>
        <li>System.out.println("Hello <span id="accent"> →줄바꿈 불가능</span>
          <br>World");
        </li>
        <li>System.out.println("Hello " <span id="comment"> →OK</span>
          <br>+ "World");
        </li>
        <li>System.out.printf("&.3f", 변수) <span id="comment"> →소수점 셋째자리까지 출력</span></li>
      </ul>
      <h3>Scanner</h3>
      <ul>
        <li><span id="accent">sc.nextInt(); </span> 정수 입력받기</li>
        <li><span id="accent">sc.nextLine(); </span> Enter전까지 입력받은 문자열을 리턴 <span id="comment">*엔터버퍼 주의*</span></li>
        <li><span id="accent">sc.next(); </span> Space전까지 입력받은 문자열을 리턴</li>
        <li><span id="accent">sc.next().charAt(0); </span> 입력받은 문자열중 첫번째 문자만 저장</li>
      </ul>

      <h1>Operator</h1>
      <p>연산식은 연산자의 수가 아무리 많아도 반드시 하나의 값을 산출한다
      <br>대부분 연산자는 <span id="accent">→ 방향</span>으로 연산되나, 단항연산자(++)와 대입연산자(+=)는 <span id="accent">← 방향</span>으로 연산된다</p>
      
      <h2>연산 자동 타입 변환</h2>
      <p>피연산자 자료형 중 더 큰 자료형으로 일치시키거나 (값손실을 최소화)
      <br><span id="accent">피연산자 모두 int보다 작을 때(byte, char, short)는 int로 변환시킨다</span> (연산시 오버플로우 가능성이 높기 때문에)
      <br><span id="comment">피연산자가 모두 리터럴일 경우 타입변환없이 계산한다 'A' + 1</span></p>

      <h2>단항 연산자</h2>
      <h3>부호연산자 (+ -)</h3>
      <p>리터럴의 부호를 표기하거나, 변수의 부호를 연산한다. 부호연산시 타입이 작은경우 int , double로 자동 변환된다</p>
      <h3>증감 연산자 (++ --)</h3>
      <p>변수의 값을 1 증가 또는 감소할 때 사용하는 연산자. 변수의 앞(prefix)과 뒤(suffix)에 사용 (x++ 또는 --x), boolean 타입을 제외한 모든 기본 타입의 피연산자에 사용가능
      <br>증감 연산자가 단독으로 사용되는 경우 전위 후위 모두 동일한 결과이나, 다른 연산자와 함께 사용되는 경우 차이 발생 <span id="accent">섞어쓰지말고 x++만 쓰자</span>
      </p>
      <ul><span id=ulh>전위 후위 연산 비교</span>
        <li>result = num++ + 5; <span id="comment"> →num + 5가 먼저 실행되고 result에 값을 저장한 뒤, num을 1 증가</span></li>
        <li>result = ++num + 5; <span id="comment"> →++num이 먼저 실행되고, num + 5의 값이 result에 저장</span></li>
        <li>result = num++ + 5 + ++num; <span id="comment"> →num + 5 연산, num++되어 num에 저장, ++num이 실행, 최종적으로 2증가한 num이
            더해짐</span></li>
      </ul>

      <h3>논리 부정 연산자 (!)</h3>
      <p>true를 false로, false를 true로 변경. boolean 타입에만 사용가능</p>

      <h2>이항 연산자</h2>
      <h3>대입연산자 (=)</h3>
      <p>오른쪽의 값을 왼쪽의 변수에 저장하는 연산자. 변수 = 값;</p>

      <h3>복합 대입 연산자 (+= -= *= %= &=)</h3>
      <p>오른쪽 피연산자(리터럴 및 변수)의 값을 좌측 피연산자인 변수에 저장한다</p>

      <h3>산술연산자 (+ - * / %)</h3>
      <p>boolean 타입을 제외한 모든 기본 타입에 사용</p>
  
      <ul><span id=ulh>정수와 실수의 산술연산</span>
        <li>5 / 2 = 2</li>
        <li>5 / 2.0 = 2.5 <span id="comment"> →실수/실수, 실수/정수, 정수/실수 : 소수점까지 계산</span></li>
        <li>System.out.println(246 / 0);<span id="comment"> →정수 0으로 나누는 것은 불가능하기 때문에 Exception발생</span></li>
        <li>System.out.println(246 / 0.0);<span id="comment"> →실수 0.0으로 나누면 Infinity</span> <span id="question">왜?? 0.0은 뒤에 소수점땜에 완전한 0이 아닌가? ㅇㅇ</span></li>
        <li>System.out.println(246 % 0.0);<span id="comment"> →NaN (Not a Number)</span></li>
      </ul>

      <h3>비교 연산자 (&lt; > &lt;= >= == !=)</h3>
      <p>대소 연산자는 boolean을 제외한 기본 타입에 사용할 수 있고, 동등 연산자는 모든 타입에 사용가능, 연산 결과로 true/false를 리턴</p>

      <h3>논리 연산자 (&& || ! ^)</h3>
      <p>boolean 타입의 변수를 사용하여 연산, 결과로 true/false를 리턴</p>
      <ul><span id=ulh>SCE (Short-circuit evaluation : Lazy Evaluation)</span>
        <li>A && B 를 계산할 때 A가 false이면, B를 계산하지 않음 <span id="comment"> →B는 Dead code</span></li>
        <li>A || B 를 계산할 때 A가 true이면, B를 계산하지 않음</li>
      </ul>

      <h1>Flow Control</h1>
      <p>프로그램의 실행 흐름을 원하는 방향으로 바꾸는 제어문. 제어문에는 조건문과 반복문이 있다.</p>
      <h2>Conditional statement</h2>
      <h3>if</h3>
      <ul>
        <li>if</li>
        <li>if - else</li>
        <li>if - else if - else <span id="comment">else if는 위의 조건식을 제외한 나머지영역에서 조건 검사를 한다</span></li>
      </ul>
      <p><span id ="comment"> if 중첩문은 else if로 바꿀 수 있는지 확인하기</span></p>
      <h3>switch</h3>
      <p>if문은 경우의 수가 많을때 조건식을 계산 처리하는 시간이 많이 걸린다 switch문은 단 하나의 표현식으로 많은 경우의 수를 처리하기 용이하다 <span id="comment">switch조건은 ==일치 연산만 가능</span>
      </p>
      <ul>
        <li>switch (변수) {
      <br>&nbsp;&nbsp; case 값1 :
      <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 코드
      <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
      <br>&nbsp;&nbsp; case 값2 :
      <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 코드
      <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
      <br>&nbsp;&nbsp; default :
      <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 코드
      <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
      <br> }
      </li>
      </ul>
      <p><span id="comment">case가 선택된순간 다른 case는 꺼지고 다음 break를 만나기 전까지의 코드가 실행된다. 예를들어 case 1: case 2: case 3: 코드; break; 에서 조건이 2일때 case 3은 꺼지고 다음 코드가 실행되고 break된다</span></p>
      <h2>Loops and iteration</h2>
      <h3>for</h3>
      <ul>
        <li><span id="accent">정해진 횟수 반복</span></li>
        <li>for (초기식; 조건식; 증감식) { 실행문 }</li>
        <li>실행순서 1.초기식 2.조건식 3.실행문 4.증감식</li>
        <li>초기식은 밖에 선언하여 생략하거나 쉽표로 두 개 이상 정의할 수도 있고, 증감식에는 다양한 식을 정의할 수 있다</li>
      </ul>
      <h3>while</h3>
      <ul>
        <li><span id="accent">조건이 true일때 계속 반복</span></li>
        <li>while (조건식) { 실행문 }</li>
      </ul>
      <h3>do - while</h3>
      <ul>
        <li><span id="accent">무조건 한 번 실행문을 실행한 후 반복문의 조건에 따라 반복 실행</span></li>
        <li>do { 실행문 } while (조건식);</li>
      </ul>
      <h3>break & continue</h3>
      <ul>
        <li><span id="accent">break;가 포함된 가장 가까운 반복문 { }을 자체를 탈출하고 종료</span>
        <br>반복문에 Label: 을 붙이고 break Label;하면 해당 반복문범위까지 종료시킨다</li>
        <li><span id="accent">continue;는 아래 명령을 실행하지 않고, 반복문의 조건식으로 돌아가 다음 반복문 절차를 수행</span></li>
        <li>while (true) 무한루프와 if를 함께 사용한다</li>
      </ul>

      <h1>Array</h1>
      <p>배열은 '같은 타입'의 여러 변수를 하나의 묶음으로 저장할 때 사용</p>
      <h3>선언과 생성</h3>
      <ul>
        <li><span id="accent">타입[ ] 배열이름;</span> 선언 : 배열을 다루기 위한 참조변수(배열이름)를 Stack 영역에 생성 (%s로 참조값 확인가능, default값은 null)</li>
        <li><span id="accent">배열이름 = new 타입[길이];</span> 생성 : 값을 저장할 실제 저장공간을 Heap 영역에 생성</li>
        <li>즉, 배열은 Heap영역의 값을 참조하는 Reference Type이다. 배열변수는 번지값을 담고있다.</li>
        <li>배열 생성시 길이 생략불가. 이후 변경불가. 길이 메소드 array.length;</li>
      </ul>

       <h3>초기화</h3>
      <p>배열은 생성과 동시에 자동적으로 해당타입의 default값으로 초기화된다. <br>그러나 원하는 값으로 지정하여 초기화도 가능하다</p>
      <ul><span id="ulh">선언 후 초기화</span>
        <li>선언 : int[] array = new int[길이];</li>
        <li>초기화 : array[index] = 값; <span id="comment">초기화란 처음 값을 넣는 것</span></li>
      </ul>
      <ul><span id="ulh">선언과 초기화 동시</span>
        <li>int[] array = { 값1, 값2, ...};</li>
        <li>int[] array = new int[] { 값1, 값2, ...}</li>
      </ul>
      <ul><span id="ulh"></span>
        <li>int[] array;<br>
        array = new int[] { 값1, 값2, 값3,,,}; <span id="comment">→변수선언과 생성을 따로하는 경우 new 생략불가</span></li>
      </ul>

      <h2>2차원 배열</h2>
      <p>1차원 배열을 원소로 갖는 중첩 배열</p>
      <ul><span id="ulh">선언</span>
        <li><span id="accent">타입[행][열] 변수이름;</span></li>
        <li><span id="comment">타입 변수이름[행][열];</span></li>
        <li><span id="comment">타입[행] 변수이름[열];</span></li>
      </ul>
      <ul><span id="ulh">길이</span>
        <li><span id="accent">array.length</span> 행의 갯수</li>
        <li><span id="accent">array[index].length</span> 지정 열의 갯수</li>
      </ul>

      <h3>객체를 참조하는 배열</h3>
      <p>String처럼 객체를 참조하는 타입의 배열은 원소로 번지값을 저장하고 있다</p>

      <h2>for - each (향상된 for문)</h2>
      <ul>
        <li>배열에 있는 모든 테이터를 접근할 때 사용</li>
        <li>for (타입 변수이름 : 배열) { ... }</li>
        <li><span id="comment">0번째부터 끝까지 접근하며 거꾸로 불가, 인덱스없이 변수에 계속 바꿔담으면서 접근, 읽기전용으로 배열에 값을 담는 것은 불가</span></li>
      </ul>

      <h1>Method</h1>
      <p>메소드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것
      <br>어떤 값을 입력(parameter)하면 이 값으로 작업을 수행해서 결과를 반환(return)
      <br>모든 메소드는 클래스내부에 소속되어, 객체의 멤버이다</p>
      <h3>정의</h3>
      <ul>
        <li><span id="accent">수식어 리턴타입 메소드이름(매개변수1, 매개변수2 ..) {본문}</span></li>
        <li><span id="comment">수식어</span> : public, private, static ..</li>
        <li><span id="comment">리턴타입</span> : 타입(int, class ..) / 없을땐 void</li>
        <li><span id="comment">매개변수</span> : 타입 변수이름 / 없을땐 생략 / 갯수모를땐 배열</li>
        <li><span id="comment">본문</span> : 메소드의 본체body. 수행해야할 기능을 작성</li>
        <li>메소드는 클래스의 내부이며, 다른 메소드의 외부인 영역에서 정의해야 한다.</li>
        <li><span id="comment">자바 컴파일시 모든 메소드를 자동으로 앞쪽에 선언하기 때문에 호출위치와 선언위치의 순서는 상관없다</span></li>
      </ul>
     
      <ul><span id="ulh">메소드 작명 관례</span>
        <li>소문자로 시작, 뒤이어오는 단어의 첫머리 글자는 대문자(Camel Case)</li>
        <li>testMethod</li>
      </ul>

      <h3>호출</h3>
      <ul>
        <li>메소드를 정의하여도 호출하지 않으면 동작하지 않는다</li>
        <li><span id="accent">메소드이름(argument);</span> argument없을때 생략</li>
      </ul>

      <h2>Return</h2>
      <p>return문이 실행되면 해당 메소드가 종료된다. 리턴값이 없는 void 메소드도 단독 return; 사용 가능하다</p>

      <h2>Overloading</h2>
      <p>매개변수가 다르면, 메소드의 이름을 동일하게 정의 할 수 있다</p>
      <ul>
        <li>매개변수의 개수가 다르거나</li>
        <li>매개변수의 타입이 다른거나</li>
        <li>매개변수의 순서가 다른경우</li>
        <li><span id="comment">메소드의 리턴타입만 다른 경우는 같은 이름으로 메소드를 정의할 수 없음 </span> → 호출할때 구분안되니깐</li>
        <li><span id="comment">매개변수 타입이 다른데 호출이 가능할수도 있다</span> → JVM은 1.일치하는 타입이 있는지 검사하고 2.없을경우 자동타입변환이 가능한지 검사하여 호출하기 때문에</li>
      </ul>
  

      <h1>Class</h1>
      <p>class에는 객체가 가져야할 구성 member가 선언된다.
      <br>객체의 속성을 <span id="accent">필드(멤버변수, 멤버상수)</span>로 선언하고, 객체의 기능동작을 <span id="accent">메소드</span>로 정의하여 새로운 <span id="accent">데이터 타입</span>을 생성한다</p>
      <ul><span id="ulh">클래스 구성</span>
        <li><span id="accent">클래스헤더(선언) :</span> [접근제한자(public,private)] [클래스종류(final,abstract)] class [클래스명(대문자로시작)] {</li>
        <li><span id="accent">필드(속성) :</span> 멤버변수, 멤버상수로 구성</li>
        <li><span id="accent">생성자 : </span> 기본생성자, 매개변수있는생성자</li>
        <li><span id="accent">메소드(동작)</span></li>
      </ul>

      <h2>Object & Instance</h2>
      <p>클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다
      <br>클래스의 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.
      </p>
      <ul><span id="ulh">인스턴스 생성</span>
        <li><span id="accent">클래스 변수이름;</span> 클래스의 객체를 참조하기 위해 참조 변수 선언 (stack 영역에 생성)</li>
        <li><span id="accent">변수이름 = new 생성자();</span> 클래스의 인스턴스를 생성한 후 (heap 영역에 생성), 주소를 참조 변수에 저장</li>
        <li>인스턴스는 참조 변수를 통해서만 다룰 수 있으며, 참조 변수의 타입은 인스턴스의 타입과 일치해야 한다</li>
        <li>인스턴스를 생성하게 되면 클래스의 멤버 변수들은 기본값으로 초기화되고, 각 인스턴스는 서로 독립적이다</li>
        <li>이때 메소드는 객체마다 존재하지 않고 메소드 영역에 저장되고 공유된다</li>
      </ul>
      
      <h3>Object Array</h3>
      <p>객체 배열은 주소를 저장한 참조변수의 주소값을 원소로 가진다. 각 원소에 해당하는 인스턴스는 독립적이다</p>

      <h2>Constructor</h2>
      <p>생성자는 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메소드이다</p>
      <ul>
        <li>생성자의 이름은 클래스의 이름과 같아야한다</li>
        <li>매개변수는 있을 수도 있고, 리턴값은 없다(void표기 X)</li>
        <li>overloading 가능</li>
        <li>상속이 안되는 유일한 멤버메소드</li>
        <li>모든 클래스는 반드시 하나 이상의 생성자가 정의되어야 하며, 없을 경우 컴파일러가 기본생성자를 자동 정의</li>
        <li><span id="comment">생성자를 하나라도 정의한 경우에는, 자동으로 기본 생성자를 만들지 않으므로 주의해야한다</span></li>
      </ul>
      
      <h3>New</h3>
      <p>연산자 new와 생성자에 의해서 heap 메모리에 클래스의 인스턴스가 생성된다.</p>
      
      <h2>This</h2>
      <p>this는 참조 변수로 생성될 인스턴스 자기 자신을 가리킨다 (Class this = new Class();)
        <br>this() 는 다른 생성자를 호출하는 생성자이다
      </p>
      
      
      <h2>package</h2>
      <p><span id="accent">package 상위패키지.하위패키지;</span>
      <br>클래스이름이 동일해도 package가 다르면 다른 클래스로 인정된다<span id="comment"> 패키지.클래스</span>
      <br><span id="comment">프로젝트 > 패키지 > 클래스 > 멤버변수/메소드 > 지역변수</span>
      </p>

      <h3>import</h3>
      <p><span id="accent">import 패키지.클래스; </span> (Ctrl + Shift + O)
      <br>다른패키지의 클래스에 접근할 때는 패키지경로를 모두 표기해야하나, import문을 선언하여 경로를 생략할 수 있다.
      <br>다른 프로젝트간의 import는 불가하다</p>

      <h1>Modifier</h1>
      <p>제어자란 변수, 메소드, 클래스, 생성자의 선언부에 함께 사용되어 부가적인 의미를 부여한다. <br>제어자의 종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.</p>
      
      <h2>Access modifier</h2>
      <p><span id="accent">멤버변수, 메소드, 클래스, 생성자에 사용가능</span></p>
      <table border="1">
      <tr>
        <th>제어자</th>
        <th>같은클래스</th>
        <th>같은패키지</th>
        <th>자손클래스</th>
        <th>전체</th>
      </tr>
      <tr>
      <td>public</td>
      <td>O</td>
      <td>O</td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <td>protected</td>
      <td>O</td>
      <td>O</td>
      <td>O</td>
      <td>X</td>
    </tr>
    <tr>
      <td>( default )</td>
      <td>O</td>
      <td>O</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td>private</td>
      <td>O</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <th colspan="5">&nbsp;&nbsp; private &lt; ( default ) &lt; protected &lt; public</th>
    </tr>
      </table>
      <ul>
        <li><span id="accent">public</span> 다른패키지 어디서든지 직접 접근 가능</li>
        <li><span id="accent">protected</span> 같은 패키지에 있거나 다른패키지여도 상속받는 클래스들에서 직접 접근 가능</li>
        <li><span id="accent">( default )</span> 같은 패키지에 있는 클래스에서 직접 접근 가능</li>
        <li><span id="accent">private</span> 선언(정의)된 클래스 안에서 직접 접근 가능</li>
      </ul>
      <h3>class access</h3>
      <p>클래스는 public / ( default ) 두 가지만 사용가능
      <br>public class는 java파일이름과 class이름이 같아야하고, 하나의 java 파일에는 하나의 public class만 있어야 한다
      <br>
    
      
      <h3>Encapsulation</h3>
      <p>클래스를 설계할 때 멤버 변수들을 private로 선언하여 외부 클래스에 필드들을 직접 접근해서 읽거나 쓰지 못하게 하는 것이며, 필요한 경우에 한하여 public 메소드(getter, setter)를 정의하여 private 멤버 변수를 간접적으로 읽거나 쓰는 것을 가능하게 할 수 있다</p>
      
      <h3>Singleton design pattern</h3>
      <p>클래스의 인스턴스를 오직 하나만 생성할 수 있도록 작성하는 설계 기법으로 인스턴스에 저장된 값을 공유해야할 때 해당기법을 사용한다. 처음 생성한 인스턴스는 변경이 불가능 (주소값이 같음)</p>
      <ul>
        <li style="list-style: decimal;">private static 클래스 Singleton = new 생성자();</li>
        <li style="list-style: decimal;">생성자는 private 로 선언</li>
        <li style="list-style: decimal;">public static 클래스 getInstance() { return Singleton; } </li>
      </ul>
      
      <h2>static</h2>
      <p><span id="accent">멤버변수, 메소드에 사용가능</span>
        <br>정적멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드(정적필드)와 메소드(정적메소드)를 말한다. 정적멤버는 객체(인스턴스)에 소속되지않고 클래스에 소속된 멤버이기 때문에 클래스멤버 라고도 한다. 프로그램이 처음 시작될 때 static 메모리 영역에 자동으로 생성</p>
        <h3>Class Member (Static Member)</h3>
        <ul>
          <li>static으로 선언한 정적필드(멤버변수)와 정적메소드</li>
          <li><span id="accent">인스턴스를 생성하지 않아도 접근 가능 </span> / static ← static(가능) / static ← instance(가능)</li>
          <li><span id="comment">static 변수는 생성되는 모든 인스턴스들이 공유하기 때문에 값의 변경에 대해서 주의해야 함</span></li>
          <li>변수 사용형식 : 클래스이름.변수이름</li>
          <li>메소드 사용형식 : 클래스이름.메소드()</li>
          <li><span id="comment"> static메소드(main포함) 내부에 인스턴스멤버나 this를 선언하고 싶다면 사용전 객체 생성을 먼저 해야한다</span></li>
        </ul>
        <h3>Instance Member</h3>
        <ul>
        <li>static이 선언되지 않은 인스턴스필드(멤버변수)와 인스턴스메소드</li>
        <li><span id="accent">인스턴스를 생성한 후에만 접근 가능</span> / instance ← instance(가능) / instance ← static(불가능)</li>
        <li>변수 사용형식 : 참조변수.변수이름</li>
        <li>메소드 사용형식 : 참조변수.메소드()</li>
      </ul>
      <p><span id="comment"> → 객체마다 가지고 있어야 할 데이터라면 인스턴스필드로 선언하는 것이 좋고, 공용적인 데이터라면 static변수로 선언하는 것이 좋다. 메소드는 인스턴스 필드를 사용한다면 인스턴스 메소드로, 인스턴스 필드를 사용하지 않는다면 정적 메소드로 선언한다</span></p>


      <h3>변수의 종류</h3>
      <p>변수의 종류를 결정짓는 중요한 요소는 <span id="accent">변수의 선언된 위치</span>이므로 변수의 종류를 파악하기 위해서는 변수가 어느 영역에 선언되었는지를 확인하는 것이 중요하다.
      <br>변수에는 크게 두 종류가 있는데 <span id="accent">멤버변수</span> 와 <span id="accent">지역변수</span> 이다. 멤버 변수 중 static 붙은 것은 클래스변수, 붙지 않는 것이 인스턴스변수이다. 멤버변수는 자동초기화가 지원된다.
      <br>멤버변수를 제외한 나머지는 지역변수이며 지역변수는 선언시 초기화가 필수이다</p>
      <ul>
        <li><span id="accent">Class Variable : </span> 클래스 영역에 선언되며 클래스가 메모리에 올라갈때 method static영역에 생성된다. 클래스변수는 인스턴스를 생성하지 않고도 바로 사용할 수 있고, 다른 모든 인스턴스가 공통된 클래스변수를 공유하게 된다.</li>
        <li><span id="accent">Instance Variable : </span> 인스턴스가 생성되었을때 인스턴스변수가 생성된다. 인스턴스변수는 인스턴스가 생성될 때마다 생성되므로 인스턴스마다 각기 다른 값을 유지한다</li>
        <li><span id="accent">Local Variable : </span> 선언된 블록{ } 내에서만 사용 가능하며 블록을 벗어나면 소멸되어 사용할 수 없게 된다. static { }안의 지역변수의 이름은 멤버변수와 동일하게 선언되면 안된다 (this불가하기때문)</li>
      </ul>
      
      <h2>final</h2>
      <p><span id="accent">변수, 메소드, 클래스에 사용가능</span></p>
      <ul>
        <li>static final 변수 : 불변의 값 상수(constant)</li>
        <li>final 변수 : 저장된 객체에서는 값을 변경할 수 없음</li>
        <li>final 메소드 : override 불가</li>
        <li>final 클래스 : 상속 불가</li>
      </ul>
      <ul><span id="ulh">final 작명 관례</span>
        <li>모든 글자는 대문자, 구분자로 _ 사용</li>
        <li><span style="font-weight: bold; color: deeppink;">FINAL_VARIABLE</span></li>
      </ul>
      
      <h1>Inheritance</h1>
      <p><span id="accent">자식클래스 extends 부모클래스</span>
      <br>상속이란 기존클래스를 재사용하여 새로운클래스를 작성하는 것이다.
      <br>다중상속은 허용되지 않으나, 상속클래스의 재상속은 가능하다</p>
      <ul>
        <li><span id="accent">상위클래스(super class), 부모클래스(parent class), 기본클래스(base class)</span></li>
        <li><span id="accent">하위클래스(sub class), 자식클래스(child class), 유도클래스(derived class)</span></li>
      </ul>
      <ul>
        <li>자손클래스는 조상클래스의 변수와 메소드 접근 가능</li>
        <li><span id="accent">조상클래스는 자손클래스의 변수와 메소드 접근 불가능</span></li>
        <li>조상멤버변수는 자손클래스의 메소드안에서 사용 가능 (필드에서 사용불가)</li>
      </ul>

      <h2>Super</h2>
      <p>super는 부모 객체를 의미한다
      <br>super( )는 부모 생성자를 의미한다</p>

      <h3>Super Constructor</h3>
      <ul>
        <li>자식클래스의 생성자가 호출되려면, 부모클래스의 생성자가 먼저 호출되어야한다</li>
        <li>자식클래스의 생성자안에서 부모클래스의 생성자를 다른 어떤 코드보다 먼저 호출해야함</li>
        <li>부모클래스의 생성자 명시적 호출 : <span id="accent">super(); super(매개변수);</span></li>
        <li>부모클래스의 생성자를 명시적으로 호출하지 않으면, 부모클래스의 기본생성자 자동 호출</li>
        <li><span id="comment">부모클래스의 매개변수있는생성자는 자동호출되지않으므로, 반드시 명시적 호출</span></li>
      </ul>

      <h2>@Override</h2>
      <ul>
        <li>조상클래스의 메소드를 자손클래스에서 메소드재정의</li>
        <li>메소드의 리턴타입, 이름, 매개변수 모두 조상클래스의 메소드와 일치해야함 (즉 본문내용만 변경가능)</li>
        <li>override되는 자손메소드는 조상메소드보다 같거나 큰 범위의 접근 제한자를 가질 수 있다</li>
        <li>override를 하면 조상메소드이름으로 자손메소드까지 한번에 묶을 수 있다</li>
      </ul>

      <h2>Class Object</h2>
      <p>java.lang.Object 클래스는 가장 최상위 조상클래스로, 모든 클래스는 Object 클래스를 상속받아 생성된다</p>

      <h3>toString</h3>
      <ul>
        <li>toString의 클래스는 Object <span id="comment">java.lang.Object.toString()</span></li>
        <li>toString은 모든 객체에서 접근가능 (모든 클래스가 Object를 상속받았으므로)</li>
        <li>Java에서는 <span id="accent">객체.toString()</span> 와 <span id="accent">객체</span> 를 같은 값을 리턴하기로 약속</li>
        <li>기본값은 getClass().getName()+'@'+Integer.toHexString(hashCode()) </li>
        <li>override 하여 재정의 가능</li>
      </ul>

      <h2>Polymorphism</h2>
      <p>다형성이란 객체(인스턴스)를 여러가지 타입으로 호출할 수 있는 것이다</p>
      <p><img src="Java_polymorphism.jpg" width="450px">
      <br><span id="accent">↑ 참조변수 cat == animal 같은 객체를 참조하고 있으므로 true</span></p>
      <ul>
        <li>조상타입으로 참조변수를 선언하여 자손 인스턴스 생성 가능</li>
        <li>조상타입 배열에 조상~자손타입 모두 저장 가능</li>
        <li>메소드의 매개변수, 리턴타입을 조상타입으로 정의하면 조상~자손타입 모두 사용 가능</li>
        <li><span id="accent">자손타입에 조상를 담을 수는 없다</span></li>
      </ul>

      <h3>Class Casting</h3>
      <p>클래스끼리 직계상속관계일때 casting 가능, 공통의 부모를 상속한 형제관계는 casting 불가
      <br><span id="comment">상속을하면 자식이 부모내용을 다 품고 있으니까 그 밑에 밑에 자식도 계속 부모를 품고있는 구조겠네 범위로 따지면 부모 &lt; 자식 &lt; 자식2 </span></p>
      <p><img src="Java_polymorphismCasting.jpg" width="500px"></p>
      <ul><span id="accent">자손→조상(up casting) : 자동 casting</span>
        <li>자손이 조상타입으로 자동타입변환되면 조상클래스의 필드와 메소드에만 접근가능하다</li>
        <li>하지만 메소드가 자손클래스에서 override되었다면 자손클래스의 메소드가 대신호출된다</li>
        <li>모든 클래스는 조상인 Object와 casting 가능</li>
      </ul>
      <ul><span id="accent">조상타입에 담긴 자손→자손(down casting) : 강제 casting</span>
        <li>강제타입변환은 자식타입이 부모타입으로 변환되어있는 상태에서만 가능</li>
        <li>부모타입변수가 부모객체를 참조하는 경우 자식타입으로 강제 변환할 수 없다</li>
        <li>이 과정을 거치면 자식클래스의 필드와 메소드에 정상적으로 접근가능</li>
      </ul> 
      
      <h3>instanceof</h3>
      <p><span id="accent">참조변수 instanceof 클래스명</span>
      <br>객체 타입 확인 연산자. 참조변수에 담긴 객체가 명시한 클래스와 같으면 true, 다르면 false를 리턴</p>

      <h2>abstract</h2>
      <h3>abstract Class</h3>
      <ul><span id="accent">abstract class 클래스이름{..}</span>
        <li>추상클래스는 new 연산자를 사용해서 인스턴스를 생성시키지 못한다</li>
        <li>따라서 상속받은 일반클래스로 인스턴스를 생성한다</li>
        <li>추상메소드를 하나라도 가지고 있다면 추상클래스가 되어야한다</li>
        <li>추상클래스를 상속한 자식클래스는 부모클래스의 추상메소드를 꼭 Override하여 정의해야한다</li>
      </ul>
      
      <h3>abstract Method</h3>
      <ul><span id="accent">abstract 리턴타입 메소드이름(매개변수,,);</span>
        <li>추상메소드는 메소드의 원형(prototype)만 선언하고 메소드의 본체(body)를 구현하지 않은 메소드이다</li>
        <li>추상클래스에서만 선언 가능하다</li>
        <li></li>
        <li></li>
      </ul>
    
      
    </div>
  </div>
</body>

</html>