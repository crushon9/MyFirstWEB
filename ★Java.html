<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>WEB_Java</title>
</head>

<link rel="stylesheet" href="CSS_Style.css">

<body>
  <h1 id="mainhead">Java</h1>
  <div class="grid">
    <div class="gridleft">
      <ul>
        <a href="★WEB.html">
          <li>WEB</li>
        </a>
        <ol>
          <a href="★HTML.html">
            <li>HTML</li>
          </a>
          <a href="★CSS.html">
            <li>CSS</li>
          </a>
          <a href="★JavaScript.html">
            <li>JavaScript</li>
          </a>
          <a href="★Java.html">
            <li id="active">Java</li>
          </a>
        </ol>
        <a href="★C.html">
          <li>C언어</li>
        </a>
        <a href="★Linux.html">
          <li>Linux</li>
        </a>
      </ul>

      <br>
      <input id="Plan2" type="button" value="Study Plan" onclick="location.href = '★Plan_java.html' ">
    </div>

    <div class="gridright">
      <h1>Java : 객체 지향 프로그래밍 언어</h1>
      <h2>Compile & Run</h2>
      <p>소스코드파일(.java)은 컴파일러(javac.exe)를 통해 컴파일되어
        <br>바이트코드파일(.class)이 생성되고 JVM(java.exe)을 통해 각 운영체제에서 실행된다.
        <br><img src="Java_JVM.jpg" width="500px" border="1">
        <ul><span id="ulh">터미널에서 컴파일하기</span>
          <li>javac 소스코드.java <span id="comment"> →class파일생성, 같은 디렉토리의 import파일 자동 컴파일</span>
          <br>javac -cp ".:경로" 소스코드.java <span id="comment"> →다른 디렉토리의 import파일 명시 --class--path
          <br>. (=현재디렉토리) : (=연결구분자) 경로</span></li>
          <li>java class파일이름 <span id="comment"> →주의 .class를 붙이지않음</span></li>
        </ul>
      </p>


      <h1>Data</h1>
      <h2>Data Type</h2>
      <table border="1">
        <thead>
          <tr>
            <th>정수</th>
            <th>Byte</th>
            <th>범위</th>
          </tr>
        </thead>
        <tr>
          <td>byte</td>
          <td>1</td>
          <td>-2⁷ ~ (2⁷-1) (-128 ~ 127)</td>
        </tr>
        <tr>
          <td>char(문자)</td>
          <td>2</td>
          <td>0 ~ (2¹⁶-1) (0 ~ 65,535) 유니코드 \u0000 ~ \uFFFF **unsgined</td>
        </tr>
        <tr>
          <td>short</td>
          <td>2</td>
          <td>-2¹⁵ ~ (2¹⁵-1) (-32,768 ~ 32,767)</td>
        </tr>
        <tr>
          <td>int</td>
          <td>4</td>
          <td>-2³¹ ~ (2³¹-1) (-2,147,483,648 ~ 2,147,483,647)</td>
        </tr>
        <tr>
          <td>long</td>
          <td>8</td>
          <td>-2⁶³ ~ (2⁶³-1) (-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807)</td>
        </tr>
        <thead>
          <tr>
            <th>실수</th>
            <th>Byte</th>
            <th>범위</th>
          </tr>
        </thead>
        <tr>
          <td>float</td>
          <td>4</td>
          <td>0x0.000002P-126f ~ 0x1.FFFFFeP+127f</td>
        </tr>
        <tr>
          <td>double</td>
          <td>8</td>
          <td>0x0.0000000000001P-1022 ~ 0x1.FFFFFFFFFFFFfP+1023 </td>
        </tr>
        <thead>
          <tr>
            <th>논리</th>
            <th>Byte</th>
            <th>범위</th>
          </tr>
        </thead>
        <tr>
          <td>boolean</td>
          <td>1</td>
          <td>true / false</td>
        </tr>
      </table>
      <ul>
        <li><span id="accent">정수 : </span>최상위비트 1bit가 부호정보를 저장하기 때문에 자료형 byte크기에서 1bit를 뺀 수의 제곱으로 표현 범위를 구할 수 있다. 만약 최상위비트가 1이라면 음의 정수이고, 십진수로 나타내려면 나머지 bit를 보수로 역전시킨 뒤 1을 더한 값에 -를 붙이면 된다.
        <br>최대/최소값 : 타입명.MAX_VALUE; </li>
        <li><span id="accent">실수 : </span> 부동소수점 타입은 2진포맷가수를 사용하기 때문에 정확한 숫자가 아닌 근사값으로 표현된다 <span id="question">범위가 왜 저렇게 나오지??</span></li>
        <li><span id="accent">문자 : </span> char는 java에서 unsgined로 동작 하므로 부호없이 2byte 모두 uni code로 쓰인다.</li>
        <li><span id="accent">논리 : </span> boolean은 1byte로 true,false를 저장한다 <span id="comment">Java에서는 boolean을 0과 1로 표기하지않음</span></li>
      </ul>
      <ul><span id="ulh">etc</span>
        <li>"H" <span id="accent"> →1글자지만 String</span></li>
        <li>"6"+"6" <span id="comment"> →문자열 연결 연산 66</span></li>
        <li>Integer.toBinaryString <span id="comment"> →정수를 2진수 문자열로 리턴</span></li> 
      
      </ul>

      <h2>Variable</h2>
      <p>변수란 하나의 값을 저장할 수 있는 메모리 공간이다
      <br> 변수는 선언된 { } 블록내에서만 사용 가능하다</p>
      <ul><span id="ulh">변수 명명 규칙</span>
        <li>첫 번재 글자는 문자이거나, '$' '_' 이어야 하고 숫자로 시작할 수 없다(필수)</li>
        <li>영어 대소문자가 구분된다(필수)</li>
        <li>첫 문자는 영어 소문자로 시작하되, 다른 단어가 붙을 경우 첫 문자를 대문자로 한다(관례)</li>
        <li>문자 길이의 제한은 없다</li>
        <li>자바 예약어(int, public, new, true, if 등) 는 사용할 수 없다(필수)</li>
      </ul>

      <h3>Constant</h3>
      <p>상수는 선언과 동시에 초기화를 해야하며, 이후 변경이 불가하다.
        <br><span id="comment">상수를 선언하는 방법 : final int x = 10;</span>
      </p>

      <h3>Literal</h3>
      <p>리터럴은 값 그 자체이다.
        <br>정수 리터럴은 기본 int(4byte)이고, long 타입은 뒤에 l 또는 L을 추가
        <br>실수 리터럴은 기본 double(8yte)이고, float 타입은 뒤에 f 또는 F를 추가
        <br>문자 리터럴은 기본적으로 char(2byte)이고, 문자열 리터럴은 기본적으로 String
      </p>

      <h2>Promotion & Casting</h2>
      <p>형 변환이란 변수나 리터럴의 타입을 다른 타입으로 변환하는 것이다.</p>
      <ul><span id="accent">자동(묵시적) 타입 변환</span>
        <li>작은타입 → 큰타입</li>
        <li>리터럴은 변수 저장시 해당 변수타입 저장 범위를 넘지 않으면 자동 타입 변환된다.</li>
        <li><span id="comment">예외 : int → float 자동변환시 int값이 float의 가수 23bit로 표현가능한 범위를 넘을 경우 정밀도 손상이 일어난다</span></li>
        </ul>
      <ul><span id="accent">강제(명시적) 타입 변환</span>
        <li>( )큰타입 → 작은타입</li>
        <li>( )로 명시하며, 데이터 손실이나 오버플로우가 발생 할 수 있다</li>
        <li><span id="comment">int num10 = (int) 3.14; 이때 0.14 값은 손실된다.</span></li>
      </ul>
      <ul><span id="ulh">etc</span>
        <li>System.out.println((int) ch1); <span id="comment"> →char를 int로 형변환하여 유니코드값 출력</span></li>
        <li>System.out.println(변수.getClass()); <span id="comment"> →변수의 자료형 출력</span></li>
      </ul>

      <h2>Primitive & Reference</h2>
      <p><img src="Java_data.jpg" width="500px" border="1"></p>
      <ul><span id="ulh">Primitive Type</span>
        <li><span id="accent">원시자료형, 더이상 쪼개어지지않음</span></li>
        <li><span id="comment">8가지 : boolean, byte, short, int, long, char, float, double</span></li>
        <li>기본값이 있기 때문에 Null이 존재하지 않는다</li>
        <li>실제 값을 저장하는 공간으로 스택(Stack) 메모리에 저장</li>
      </ul>
      <ul><span id="ulh">Reference Type</span>
        <li><span id="accent">원시자료형을 제외한 모든 타입은 참조자료형, 객체(Object)의 주소를 참조한다.</span></li>
        <li><span id="comment">Class(String), Interface, Enum, Array</span></li>
        <li>빈 객체를 의미하는 Null이 기본값이다</li>
        <li>힙(Heap)영역에 생성된 객체의 주소값이 스택(Stack)영역에 참조자료형으로 저장된다. 즉 스택에는 참조값만 있고 실제값은 힙에 존재한다</li>
      </ul>
      <h3>== & equals()</h3>
      <p><img src="Java_equals.jpg" width="600px" border="1"></p>
      <ul>
        <li>==는 같은 데이터를 가리키는지 확인하는 연산자이고 (Primitive type에 사용)</li>
        <li>equals()는 담긴 데이터가 같은지 비교하는 메소드이다 (Reference type에 사용)</li>
        <li>java에서 문자열 리터럴이 동일하다면 동일한 Stirng을 참조한다(==가능)
        <br>하지만 new로 생성한 새로운 String은 다른 번지를 가지게된다(==불가능)</li>
      </ul>
      <ul>
        <li>call by value 값을 넘겨줘서 해당 값을 저장하여 작업</li>
        <li>call by reference 주소값을 전달하기 때문에 어느 위치에서든 같은 객체 (메소드로 리턴값으로 주고받지않아도 원본값이 수정됨)</li>
      </ul>

      <h2>Print & Scanner</h2>
      <h3>Print</h3>
      <ul>
        <li><span id="accent">System.out.println(); </span> 출력 후 개행</li>
        <li><span id="accent">System.out.print(); </span> 개행없이 출력</li>
        <li><span id="accent">System.out.printf(); </span> 변수의 값을 지시자 형식으로 변환하여 출력</li>
 
      </ul>
      <ul><span id="ulh">etc</span>
        <li>System.out.println("Hello \"World\""); <span id="comment"> →escape</span></li>
        <li>System.out.println("Hello <span id="accent"> →줄바꿈 불가능</span>
          <br>World");
        </li>
        <li>System.out.println("Hello " <span id="comment"> →OK</span>
          <br>+ "World");
        </li>
        <li>System.out.printf("&.3f", 변수) <span id="comment"> →소수점 셋째자리까지 출력</span></li>
      </ul>
      <h3>Scanner</h3>
      <ul>
        <li><span id="accent">sc.nextInt(); </span> 정수 입력받기</li>
        <li><span id="accent">sc.nextLine(); </span> Enter전까지 입력받은 문자열을 리턴 <span id="comment">*엔터버퍼 주의*</span></li>
        <li><span id="accent">sc.next(); </span> Space전까지 입력받은 문자열을 리턴</li>
        <li><span id="accent">sc.next().charAt(0); </span> 입력받은 문자열중 첫번째 문자만 저장</li>
      </ul>

      <h1>Operator</h1>
      <p>연산식은 연산자의 수가 아무리 많아도 반드시 하나의 값을 산출한다
      <br>대부분 연산자는 <span id="accent">→ 방향</span>으로 연산되나, 단항연산자(++)와 대입연산자(+=)는 <span id="accent">← 방향</span>으로 연산된다</p>
      
      <h2>연산 자동 타입 변환</h2>
      <p>피연산자 자료형 중 더 큰 자료형으로 일치시키거나 (값손실을 최소화)
      <br><span id="accent">피연산자 모두 int보다 작을 때(byte, char, short)는 int로 변환시킨다</span> (연산시 오버플로우 가능성이 높기 때문에)
      <br><span id="comment">피연산자가 모두 리터럴일 경우 타입변환없이 계산한다 'A' + 1</span></p>

      <h2>단항 연산자</h2>
      <h3>부호연산자 (+ -)</h3>
      <p>리터럴의 부호를 표기하거나, 변수의 부호를 연산한다. 부호연산시 타입이 작은경우 int , double로 자동 변환된다</p>
      <h3>증감 연산자 (++ --)</h3>
      <p>변수의 값을 1 증가 또는 감소할 때 사용하는 연산자. 변수의 앞(prefix)과 뒤(suffix)에 사용 (x++ 또는 --x), boolean 타입을 제외한 모든 기본 타입의 피연산자에 사용가능
      <br>증감 연산자가 단독으로 사용되는 경우 전위 후위 모두 동일한 결과이나, 다른 연산자와 함께 사용되는 경우 차이 발생 <span id="accent">섞어쓰지말고 x++만 쓰자</span>
      </p>
      <ul><span id=ulh>전위 후위 연산 비교</span>
        <li>result = num++ + 5; <span id="comment"> →num + 5가 먼저 실행되고 result에 값을 저장한 뒤, num을 1 증가</span></li>
        <li>result = ++num + 5; <span id="comment"> →++num이 먼저 실행되고, num + 5의 값이 result에 저장</span></li>
        <li>result = num++ + 5 + ++num; <span id="comment"> →num + 5 연산, num++되어 num에 저장, ++num이 실행, 최종적으로 2증가한 num이
            더해짐</span></li>
      </ul>

      <h3>논리 부정 연산자 (!)</h3>
      <p>true를 false로, false를 true로 변경. boolean 타입에만 사용가능</p>

      <h2>이항 연산자</h2>
      <h3>대입연산자 (=)</h3>
      <p>오른쪽의 값을 왼쪽의 변수에 저장하는 연산자. 변수 = 값;</p>

      <h3>복합 대입 연산자 (+= -= *= %= &=)</h3>
      <p>오른쪽 피연산자(리터럴 및 변수)의 값을 좌측 피연산자인 변수에 저장한다</p>

      <h3>산술연산자 (+ - * / %)</h3>
      <p>boolean 타입을 제외한 모든 기본 타입에 사용</p>
  
      <ul><span id=ulh>정수와 실수의 산술연산</span>
        <li>5 / 2 = 2</li>
        <li>5 / 2.0 = 2.5 <span id="comment"> →실수/실수, 실수/정수, 정수/실수 : 소수점까지 계산</span></li>
        <li>System.out.println(246 / 0);<span id="comment"> →정수 0으로 나누는 것은 불가능하기 때문에 Exception발생</span></li>
        <li>System.out.println(246 / 0.0);<span id="comment"> →실수 0.0으로 나누면 Infinity</span> <span id="question">왜?? 0.0은 뒤에 소수점땜에 완전한 0이 아닌가? ㅇㅇ</span></li>
        <li>System.out.println(246 % 0.0);<span id="comment"> →NaN (Not a Number)</span></li>
      </ul>

      <h3>비교 연산자 (&lt; > &lt;= >= == !=)</h3>
      <p>대소 연산자는 boolean을 제외한 기본 타입에 사용할 수 있고, 동등 연산자는 모든 타입에 사용가능, 연산 결과로 true/false를 리턴</p>

      <h3>논리 연산자 (&& || ! ^)</h3>
      <p>boolean 타입의 변수를 사용하여 연산, 결과로 true/false를 리턴</p>
      <ul><span id=ulh>SCE (Short-circuit evaluation : Lazy Evaluation)</span>
        <li>A && B 를 계산할 때 A가 false이면, B를 계산하지 않음 <span id="comment"> →B는 Dead code</span></li>
        <li>A || B 를 계산할 때 A가 true이면, B를 계산하지 않음</li>
      </ul>

      <h1>Flow Control</h1>
      <p>프로그램의 실행 흐름을 원하는 방향으로 바꾸는 제어문. 제어문에는 조건문과 반복문이 있다.</p>
      <h2>Conditional statement</h2>
      <h3>if</h3>
      <ul>
        <li>if</li>
        <li>if - else</li>
        <li>if - else if - else <span id="comment">else if는 위의 조건식을 제외한 나머지영역에서 조건 검사를 한다</span></li>
      </ul>
      <p><span id ="comment"> if 중첩문은 else if로 바꿀 수 있는지 확인하기</span></p>
      <h3>switch</h3>
      <p>if문은 경우의 수가 많을때 조건식을 계산 처리하는 시간이 많이 걸린다 switch문은 단 하나의 표현식으로 많은 경우의 수를 처리하기 용이하다 <span id="comment">switch조건은 ==일치 연산만 가능</span>
      </p>
      <ul>
        <li>switch (변수) {
      <br>&nbsp;&nbsp; case 값1 :
      <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 코드
      <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
      <br>&nbsp;&nbsp; case 값2 :
      <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 코드
      <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
      <br>&nbsp;&nbsp; default :
      <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 코드
      <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
      <br> }
      </li>
      </ul>
      <p><span id="comment">case가 선택된순간 다른 case는 꺼지고 다음 break를 만나기 전까지의 코드가 실행된다. 예를들어 case 1: case 2: case 3: 코드; break; 에서 조건이 2일때 case 3은 꺼지고 다음 코드가 실행되고 break된다</span></p>
      <h2>Loops and iteration</h2>
      <h3>for</h3>
      <ul>
        <li><span id="accent">정해진 횟수 반복</span></li>
        <li>for (초기식; 조건식; 증감식) { 실행문 }</li>
        <li>실행순서 1.초기식 2.조건식 3.실행문 4.증감식</li>
        <li>초기식은 밖에 선언하여 생략하거나 쉽표로 두 개 이상 정의할 수도 있고, 증감식에는 다양한 식을 정의할 수 있다</li>
      </ul>
      <h3>while</h3>
      <ul>
        <li><span id="accent">조건이 true일때 계속 반복</span></li>
        <li>while (조건식) { 실행문 }</li>
      </ul>
      <h3>do - while</h3>
      <ul>
        <li><span id="accent">무조건 한 번 실행문을 실행한 후 반복문의 조건에 따라 반복 실행</span></li>
        <li>do { 실행문 } while (조건식);</li>
      </ul>
      <h3>break & continue</h3>
      <ul>
        <li><span id="accent">break;가 포함된 가장 가까움 반복문 { }을 자체를 탈출하고 종료</span></li>
        <li><span id="accent">continue;는 아래 명령을 실행하지 않고, 반복문의 조건식으로 돌아가 다음 반복문 절차를 수행</span></li>
        <li>while (true) 무한루프와 if를 함께 사용한다</li>
      </ul>
      <h3>for - each</h3>
      <ul>
        <li>for-each문 (향상된 for문) : 배열에 있는 모든 테이터를 접근할 때 사용</li>
        <li>for (타입 변수이름 : 배열) { ... }</li>
        <li><span id="comment">0번째부터 끝까지 접근하며 거꾸로 불가, 인덱스없이 변수에 계속 바꿔담으면서 접근, 배열에 값을 담는 것은 불가</span></li>
      </ul>

      <h1>Array</h1>
      <p>배열은 '같은 타입'의 여러 변수를 하나의 묶음으로 저장할 때 사용</p>
      <h2>선언과 생성</h2>
      <ul>
        <li><span id="accent">타입[ ] 배열이름;</span> 선언 : 배열을 다루기 위한 참조변수(배열이름)를 Stack 영역에 생성 (%s로 참조값 확인가능, default값은 null)</li>
        <li><span id="accent">배열이름 = new 타입[길이];</span> 생성 : 값을 저장할 실제 저장공간을 Heap 영역에 생성</li>
        <li>즉, 배열은 Heap영역의 값을 참조하는 Reference Type이다.</li>
        <li>배열 생성시 길이 생략불가. 길이 메소드 array.length;</li>
      </ul>

       <h2>초기화</h2>
      <p>배열은 생성과 동시에 자동적으로 해당타입의 default값으로 초기화된다. <br>그러나 원하는 값으로 지정하여 초기화도 가능하다</p>
      <ul><span id="ulh">선언 후 초기화</span>
        <li>선언 : int[] array = new int[길이];</li>
        <li>초기화 : array[index] = 값; <span id="comment">초기화란 처음 값을 넣는 것</span></li>
      </ul>
      <ul><span id="ulh">선언과 초기화 동시</span>
        <li>int[] array = { 값1, 값2, ...};</li>
        <li>int[] array = new int[] { 값1, 값2, ...}</li>
      </ul>
      <ul><span id="ulh"></span>
        <li>int[] array;<br>
        array = new int[] { 값1, 값2, 값3,,,}; <span id="comment">→변수선언과 생성을 따로하는 경우 new 생략불가</span></li>
      </ul>

      <h2>2차원 배열</h2>
      <p>1차원 배열을 원소로 갖는 배열</p>
      <ul><span id="ulh">선언</span>
        <li><span id="accent">타입[행][열] 변수이름;</span></li>
        <li><span id="comment">타입 변수이름[행][열];</span></li>
        <li><span id="comment">타입[행] 변수이름[열];</span></li>
      </ul>
      <ul><span id="ulh">길이</span>
        <li><span id="accent">array.length</span> 행의 갯수</li>
        <li><span id="accent">array[index].length</span> 지정 열의 갯수</li>
      </ul>

      <h1>Method</h1>
      <p>메소드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것
      <br>어떤 값을 입력(parameter)하면 이 값으로 작업을 수행해서 결과를 반환(return)</p>
      <h2>정의</h2>
      <ul>
        <li><span id="accent">수식어 리턴타입 메소드이름(매개변수1, 매개변수2 ..) {본문}</span></li>
        <li><span id="comment">수식어</span> : public(생략가능), private, static ..</li>
        <li><span id="comment">리턴타입</span> : 타입(int, class ..) / 없을땐 void</li>
        <li><span id="comment">매개변수</span> : 메소드를 호출할 때 input 데이터 / 없을땐 생략</li>
        <li><span id="comment">본문</span> : 메소드의 본체body. 수행해야할 기능을 작성</li>
        <li>메소드는 클래스의 내부이며, 다른 메소드의 외부인 영역에서 정의해야 한다.</li>
        <li>자바 컴파일시 모든 메소드를 자동으로 앞쪽에 선언하기 때문에 호출위치와 선언위치의 순서는 상관없다</li>
      </ul>
      <h2>호출</h2>
      <ul>
        <li>메소드를 정의하여도 호출하지 않으면 동작하지 않는다</li>
        <li><span id="accent">메소드이름(argument);</span> argument없을때 생략</li>
      </ul>

      <h2>Overloading</h2>
      <p>매개변수가 다르면, 메소드의 이름을 동일하게 정의 할 수 있다</p>
      <ul>
        <li>매개변수의 개수가 다르거나</li>
        <li>매개변수의 타입이 다른거나</li>
        <li>매개변수의 순서가 다른경우</li>
        <li><span id="comment">메소드의 리턴타입만 다른 경우는 같은 이름으로 메소드를 정의할 수 없음 </span> ->호출할때 구분안되니깐</li>
      </ul>

    </div>
  </div>
</body>

</html>