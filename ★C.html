<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>C언어</title>
</head>

<link rel="stylesheet" href="CSS_Style.css">

<body>
  <h1 id="mainhead">C언어</h1>
  <div class="grid">
    <div class="gridleft">
      <ul>
        <a href="★Java.html"><li>Java</li></a>
        <a href="★C.html"><li id="active">C언어</li></a>
        <a href="★WEB.html"><li>WEB</li></a>
          <ol>
            <a href="★HTML.html"><li>HTML</li></a>
            <a href="★CSS.html"><li>CSS</li></a>
            <a href="★JavaScript.html"><li>JavaScript</li></a>
            <a href="★Ajax.html"><li>Ajax</li></a>
            <a href="★JSP.html"><li>JSP</li></a> 
          </ol>
        <a href="★Linux.html"><li>Linux</li></a>
        <a href="★DataBase.html"><li>DataBase</li></a>
          <ol>
            <a href="★OracleDB.html"><li>OracleDB</li></a>
          </ol>
      </ul>

      <br>
      <input id="Plan" type="button" value="Study Plan" onclick="location.href = '★Plan_C.html' ">
    </div>

    <div class="gridright">

      <h1>C 언어</h1>
      <p>C 언어는 1972년 켄 톰슨과 데니스 리치가 벨 연구소에서 일할 당시 유닉스 운영체제를 만들기 위해 고안한 프로그래밍 언어입니다.
        켄 톰슨은 BCPL 언어를 입맛에 맞게 고쳐서 B 언어(벨 연구소의 B)를 개발하고
        데니스 리치가 B 언어를 개선하여 C 언어가 탄생했습니다.
        C 언어는 이후의 프로그래밍 언어에 직간접적으로 많은 영향을 주었습니다
        즉, 프로그래밍 세계의 공통어라 할 수 있습니다.
        우리가 지금도 쓰고 있는 Windows, 리눅스, OS X와 iOS, Android, Windows Phone 모바일 운영체제의 핵심 요소인 커널은 C 언어로 만들어져 있습니다(약간의 어셈블리가
        포함됨).
        즉, 운영체제의 모든 기능을 이용할 수 있는 건 C 언어죠.
        다른 언어들은 모두 C 언어의 기능(라이브러리)을 가져다 쓰는 구조입니다.
        <br><span id="accent">BCPL → B언어 → C언어 → C++, Java, C#, PHP, Python, Ruby,,,</span>
      </p>


      <h3>컴파일(Compile) </h3>
      <p>컴파일(Compile)은 주어진 language로 작성된 컴퓨터 프로그램을 다른 언어의 동등한 프로그램으로 변환하는 프로세스입니다.
        <br><span id="accent">소스코드편집(.c) → 컴파일(.obj) → 실행(.exe)</span>
      </p>

      <h3>입력과 출력</h3>
      <p>Windows나 OS X처럼 GUI 화면이 나오는 프로그램은 마우스와 키보드를 사용하여 입력을 받습니다. 하지만 C 언어를 배울 때는 콘솔(터미널, 명령 프롬프트)에서 글자만 입출력 하게 되죠.
      </p>
      <ul>
        <li>표준 입력(standard input, stdin) : 콘솔에서 키보드 입력</li>
        <li>표준 출력(standard output, stdout) : 콘솔에 글자를 보여주는 것</li>
      </ul>


      <h1>변수와 자료형</h1>
      <p>C 언어는 변수에 저장할 값의 종류에 따라 자료형이 달라집니다.</p>
      <ul><span id="ulh">자료형의 종류</span>
        <li>정수 : char(문자), short, int, long, long long</li>
        <li>실수 : float, double, long double</li>
        <li>void 형태가 없는 자료형 <span id="comment">포인터를 사용할 때, 함수의 반환값을 표현할 때 등 다양하게 사용됩니다</span></li>
      </ul>
      <ul><span id="ulh">변수 작명 규칙</span>
        <li>영문 문자와 숫자를 사용할 수 있습니다.</li>
        <li>대소문자를 구분합니다.</li>
        <li>문자부터 시작해야 하며 숫자부터 시작하면 안 됩니다.</li>
        <li>_ (밑줄)로 시작할 수 있습니다.</li>
        <li>C 언어의 키워드(int, short, long, float, void, if, for, while, switch 등)는 사용할 수 없습니다.</li>
      </ul>
      <ul><span id="ulh">변수 할당</span>
        <li>변수를 선언하면서 값을 할당하는 것을 초기화라고 한다.</li>
        <li>중복선언 할때는 int num2 = 20, num3 = 30; 같이 선언한다.</li>
        <li><span id="question">의문 : 변수와 할당값의 좌우가 바뀌면 안되나?
            <br>답 : ㅇㅇ 그래서 변수와 상수에 좌항 우항이란 용어를 쓰나봄</span></li>
      </ul>


      <h3>바이트크기구하기(sizeof)</h3>
      <p>자료형(타입)의 크기를 바이트(byte) 단위로 구하는 연산자</p>
      <ul><span id="ulh"></span>
        <li>sizeof 변수</li>
        <li>sizeof(변수)</li>
        <li>sizeof(자료형) <span id="comment">→자료형 자체의 크기 구할 때는 반드시 ( )를 지정</span></li>
      </ul>


      <h2>정수 (char, short, int, long, long long)</h2>
      <br>
      <table border="1">
        <thead>
          <tr>
            <th>자료형</th>
            <th>크기</th>
            <th>범위</th>
            <th>비고</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>char <br>signed char</td>
            <td>1바이트, 8비트</td>
            <td>-128~127</td>
            <td>&nbsp;</td>
          </tr>
          <tr>
            <td>unsigned char</td>
            <td>1바이트, 8비트</td>
            <td>0~255</td>
            <td>&nbsp;</td>
          </tr>
          <tr>
            <td>short <br>short int</td>
            <td>2바이트, 16비트</td>
            <td>-32,768~32,767</td>
            <td>int 생략 가능</td>
          </tr>
          <tr>
            <td>unsigned short <br>unsigned short int</td>
            <td>2바이트, 16비트</td>
            <td>0~65,535</td>
            <td>int 생략 가능</td>
          </tr>
          <tr>
            <td>int<br>signed int</td>
            <td>4바이트, 32비트</td>
            <td>-2,147,483,648~ 2,147,483,647</td>
            <td>&nbsp;</td>
          </tr>
          <tr>
            <td>unsigned <br>unsigned int</td>
            <td>4바이트, 32비트</td>
            <td>0~4,294,967,295</td>
            <td>int 생략 가능</td>
          </tr>
          <tr>
            <td>long<br>long int<br>signed long<br>signed long int</td>
            <td>4바이트, 32비트</td>
            <td>-2,147,483,648~ 2,147,483,647</td>
            <td>int 생략 가능</td>
          </tr>
          <tr>
            <td>unsigned long <br>unsigned long int</td>
            <td>4바이트, 32비트</td>
            <td>0~4,294,967,295</td>
            <td>int</span> 생략 가능</td>
          </tr>
          <tr>
            <td>long long <br>long long int <br>signed long long <br>signed long long int</td>
            <td>8바이트, 64비트</td>
            <td>-9,223,372,036,854,775,808~<br>9,223,372,036,854,775,807</td>
            <td>int 생략 가능</td>
          </tr>
          <tr>
            <td>unsigned long long <br>unsigned long long int</td>
            <td>8바이트, 64비트</td>
            <td>0~18,446,744,073,709,551,615</td>
            <td>int 생략 가능</td>
          </tr>
        </tbody>
      </table>
      <p id="comment">C99 표준부터는 stdint.h 헤더 파일로. 크기가 표시된 정수 자료형으로 변수를 선언한다. 자료형 이름에 비트 단위로 크기와 부호를 표시한다. int8_t, uint16_t</p>

      <h3>정수_서식지정자</h3>
      <ul><span id="ulh"></span>
        <li>%d : decimal(10진수) <span id="comment">→ char, short, int</span></li>
        <li>%ld : long decimal <span id="comment">→ long</span></li>
        <li>%lld: long long decimal <span id="comment">→ long long</span></li>
        <li><span id="comment">%05d : 앞자리를 0으로 채워 최대 5자리로</span></li>
        <li>%u : unsigned decimal</li>
        <li>%lu : long unsigned decimal</li>
        <li>%llu : long long unsigned decimal</li>
        <li>0x%x : hexadecimal(16진수) <span id="accent">16진수도 정수이다</span></li>
        <li><span id="comment">0x%X : 16진수의 알파벳을 대문자로 표시</span></li>
        <li>0%o: octalnumber(8진수) </li>
      </ul>

      <h3>정수_최대최소(limits.h)</h3>
      <p>limits.h 헤더 파일에는 정수 자료형의 최솟값과 최댓값이 정의되어 있습니다
        <br>char num1 = CHAR_MAX; 결과값은 127
      </p>
      <table border="1">
        <thead>
          <tr>
            <th>자료형</th>
            <th>최솟값</th>
            <th>최댓값</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>char</td>
            <td>CHAR_MIN</td>
            <td>CHAR_MAX</td>
          </tr>
          <tr>
            <td>short</td>
            <td>SHRT_MIN</td>
            <td>SHRT_MAX</td>
          </tr>
          <tr>
            <td>int</td>
            <td>INT_MIN</td>
            <td>INT_MAX</td>
          </tr>
          <tr>
            <td>long</td>
            <td>LONG_MIN</td>
            <td>LONG_MAX</td>
          </tr>
          <tr>
            <td>long long</td>
            <td>LLONG_MIN</td>
            <td>LLONG_MAX</td>
          </tr>
          <tr>
            <td>unsigned char</td>
            <td>0</td>
            <td>UCHAR_MAX</td>
          </tr>
          <tr>
            <td>unsigned short</td>
            <td>0</td>
            <td>USHRT_MAX</td>
          </tr>
          <tr>
            <td>unsigned int</td>
            <td>0</td>
            <td>UINT_MAX</td>
          </tr>
          <tr>
            <td>unsigned long</td>
            <td>0</td>
            <td>ULONG_MAX</td>
          </tr>
          <tr>
            <td>unsigned long long</td>
            <td>0</td>
            <td>ULLONG_MAX</td>
          </tr>
        </tbody>
      </table>

      <h3>정수_오버플로우&언더플로우</h3>
      <p>오버플로우나 언더플로우 현상이 발생하면 의도치 않은 결과가 나올 수 있습니다. 따라서 프로그래밍할때는 정수 자료형의 크기를 항상 생각하고, 값이 범위를 넘어서지는 않는지 반드시 확인합니다.
        <br><img src="C언어_정수오버플로우.JPG" border="1" width="600px">
      </p>

      <h2>문자 (char)</h2>
      <p>아스키(ASCII)코드란 각 정숫값이 어떤 문자에 해당되는지 표로 나타낸 것이다. 아스키코드는 0부터 127까지 총 128가지의 문자를 나타낸다. 즉 7bit로 표현할 수 있다. 그러므로 1byte인
        char 자료형으로 아스키코드 1개를 표현할 수 있다.
        <br>C언어에서는 정수 자료형인 char를 이용하여 문자 한 개를 저장한다. char에 문자를 저장할 때는 문자 자체를 저장하는 것이 아니라 문자에 해당하는 정숫값을 저장한다.
        <br>아스키코드만으로는 다양한 나라의 언어 등 복잡한 문자를 나타낼 수 없기 때문에 확장된 유니코드 체계를 이용하여 다양한 문자를 표현한다.
      </p>
      <table border="1">
        <thead>
          <tr>
            <th>자료형</th>
            <th>크기</th>
            <th>범위</th>
            <th>비고</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>char<br>signed char</td>
            <td>1바이트, 8비트</td>
            <td>-128~127</td>
            <td>문자 저장</td>
          </tr>
          <tr>
            <td>unsigned char</td>
            <td>1바이트, 8비트</td>
            <td>0~255</td>
            <td>바이트 단위 데이터 저장</td>
          </tr>
        </tbody>
      </table>
      <br>
      <table border="1">
        <thead>
          <tr>
            <th>10진수</th>
            <th>16진수</th>
            <th>문자(ASCII)</th>
            <th>10진수</th>
            <th>16진수</th>
            <th>문자(ASCII)</th>
            <th>10진수</th>
            <th>16진수</th>
            <th>문자(ASCII)</th>
            <th>10진수</th>
            <th>16진수</th>
            <th>문자(ASCII)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>0</td>
            <td>0x00</td>
            <td>NUL</td>
            <td>32</td>
            <td>0x20</td>
            <td>Space</td>
            <td>64</td>
            <td>0x40</td>
            <td>@</td>
            <td>96</td>
            <td>0x60</td>
            <td>`</td>
          </tr>
          <tr>
            <td>1</td>
            <td>0x01</td>
            <td>SOH</td>
            <td>33</td>
            <td>0x21</td>
            <td>!</td>
            <td>65</td>
            <td>0x41</td>
            <td>A</td>
            <td>97</td>
            <td>0x61</td>
            <td>a</td>
          </tr>
          <tr>
            <td>2</td>
            <td>0x02</td>
            <td>STX</td>
            <td>34</td>
            <td>0x22</td>
            <td>"</td>
            <td>66</td>
            <td>0x42</td>
            <td>B</td>
            <td>98</td>
            <td>0x62</td>
            <td>b</td>
          </tr>
          <tr>
            <td>3</td>
            <td>0x03</td>
            <td>ETX</td>
            <td>35</td>
            <td>0x23</td>
            <td>#</td>
            <td>67</td>
            <td>0x43</td>
            <td>C</td>
            <td>99</td>
            <td>0x63</td>
            <td>c</td>
          </tr>
          <tr>
            <td>4</td>
            <td>0x04</td>
            <td>EOT</td>
            <td>36</td>
            <td>0x24</td>
            <td>$</td>
            <td>68</td>
            <td>0x44</td>
            <td>D</td>
            <td>100</td>
            <td>0x64</td>
            <td>d</td>
          </tr>
          <tr>
            <td>5</td>
            <td>0x05</td>
            <td>ENQ</td>
            <td>37</td>
            <td>0x25</td>
            <td>%</td>
            <td>69</td>
            <td>0x45</td>
            <td>E</td>
            <td>101</td>
            <td>0x65</td>
            <td>e</td>
          </tr>
          <tr>
            <td>6</td>
            <td>0x06</td>
            <td>ACK</td>
            <td>38</td>
            <td>0x26</td>
            <td>&amp;</td>
            <td>70</td>
            <td>0x46</td>
            <td>F</td>
            <td>102</td>
            <td>0x66</td>
            <td>f</td>
          </tr>
          <tr>
            <td>7</td>
            <td>0x07</td>
            <td>BEL</td>
            <td>39</td>
            <td>0x27</td>
            <td>'</td>
            <td>71</td>
            <td>0x47</td>
            <td>G</td>
            <td>103</td>
            <td>0x67</td>
            <td>g</td>
          </tr>
          <tr>
            <td>8</td>
            <td>0x08</td>
            <td>BS</td>
            <td>40</td>
            <td>0x28</td>
            <td>(</td>
            <td>72</td>
            <td>0x48</td>
            <td>H</td>
            <td>104</td>
            <td>0x68</td>
            <td>h</td>
          </tr>
          <tr>
            <td>9</td>
            <td>0x09</td>
            <td>TAB</td>
            <td>41</td>
            <td>0x29</td>
            <td>)</td>
            <td>73</td>
            <td>0x49</td>
            <td>I</td>
            <td>105</td>
            <td>0x69</td>
            <td>i</td>
          </tr>
          <tr>
            <td>10</td>
            <td>0x0A</td>
            <td>LF</td>
            <td>42</td>
            <td>0x2A</td>
            <td>*</td>
            <td>74</td>
            <td>0x4A</td>
            <td>J</td>
            <td>106</td>
            <td>0x6A</td>
            <td>j</td>
          </tr>
          <tr>
            <td>11</td>
            <td>0x0B</td>
            <td>VT</td>
            <td>43</td>
            <td>0x2B</td>
            <td>+</td>
            <td>75</td>
            <td>0x4B</td>
            <td>K</td>
            <td>107</td>
            <td>0x6B</td>
            <td>k</td>
          </tr>
          <tr>
            <td>12</td>
            <td>0x0C</td>
            <td>FF</td>
            <td>44</td>
            <td>0x2C</td>
            <td>,</td>
            <td>76</td>
            <td>0x4C</td>
            <td>L</td>
            <td>108</td>
            <td>0x6C</td>
            <td>l</td>
          </tr>
          <tr>
            <td>13</td>
            <td>0x0D</td>
            <td>CR</td>
            <td>45</td>
            <td>0x2D</td>
            <td>-</td>
            <td>77</td>
            <td>0x4D</td>
            <td>M</td>
            <td>109</td>
            <td>0x6D</td>
            <td>m</td>
          </tr>
          <tr>
            <td>14</td>
            <td>0x0E</td>
            <td>SO</td>
            <td>46</td>
            <td>0x2E</td>
            <td>.</td>
            <td>78</td>
            <td>0x4E</td>
            <td>N</td>
            <td>110</td>
            <td>0x6E</td>
            <td>n</td>
          </tr>
          <tr>
            <td>15</td>
            <td>0x0F</td>
            <td>SI</td>
            <td>47</td>
            <td>0x2F</td>
            <td>/</td>
            <td>79</td>
            <td>0x4F</td>
            <td>O</td>
            <td>111</td>
            <td>0x6F</td>
            <td>o</td>
          </tr>
          <tr>
            <td>16</td>
            <td>0x10</td>
            <td>DLE</td>
            <td>48</td>
            <td>0x30</td>
            <td>0</td>
            <td>80</td>
            <td>0x50</td>
            <td>P</td>
            <td>112</td>
            <td>0x70</td>
            <td>p</td>
          </tr>
          <tr>
            <td>17</td>
            <td>0x11</td>
            <td>DC1</td>
            <td>49</td>
            <td>0x31</td>
            <td>1</td>
            <td>81</td>
            <td>0x51</td>
            <td>Q</td>
            <td>113</td>
            <td>0x71</td>
            <td>q</td>
          </tr>
          <tr>
            <td>18</td>
            <td>0x12</td>
            <td>DC2</td>
            <td>50</td>
            <td>0x32</td>
            <td>2</td>
            <td>82</td>
            <td>0x52</td>
            <td>R</td>
            <td>114</td>
            <td>0x72</td>
            <td>r</td>
          </tr>
          <tr>
            <td>19</td>
            <td>0x13</td>
            <td>DC3</td>
            <td>51</td>
            <td>0x33</td>
            <td>3</td>
            <td>83</td>
            <td>0x53</td>
            <td>S</td>
            <td>115</td>
            <td>0x73</td>
            <td>s</td>
          </tr>
          <tr>
            <td>20</td>
            <td>0x14</td>
            <td>DC4</td>
            <td>52</td>
            <td>0x34</td>
            <td>4</td>
            <td>84</td>
            <td>0x54</td>
            <td>T</td>
            <td>116</td>
            <td>0x74</td>
            <td>t</td>
          </tr>
          <tr>
            <td>21</td>
            <td>0x15</td>
            <td>NAK</td>
            <td>53</td>
            <td>0x35</td>
            <td>5</td>
            <td>85</td>
            <td>0x55</td>
            <td>U</td>
            <td>117</td>
            <td>0x75</td>
            <td>u</td>
          </tr>
          <tr>
            <td>22</td>
            <td>0x16</td>
            <td>SYN</td>
            <td>54</td>
            <td>0x36</td>
            <td>6</td>
            <td>86</td>
            <td>0x56</td>
            <td>V</td>
            <td>118</td>
            <td>0x76</td>
            <td>v</td>
          </tr>
          <tr>
            <td>23</td>
            <td>0x17</td>
            <td>ETB</td>
            <td>55</td>
            <td>0x37</td>
            <td>7</td>
            <td>87</td>
            <td>0x57</td>
            <td>W</td>
            <td>119</td>
            <td>0x77</td>
            <td>w</td>
          </tr>
          <tr>
            <td>24</td>
            <td>0x18</td>
            <td>CAN</td>
            <td>56</td>
            <td>0x38</td>
            <td>8</td>
            <td>88</td>
            <td>0x58</td>
            <td>X</td>
            <td>120</td>
            <td>0x78</td>
            <td>x</td>
          </tr>
          <tr>
            <td>25</td>
            <td>0x19</td>
            <td>EM</td>
            <td>57</td>
            <td>0x39</td>
            <td>9</td>
            <td>89</td>
            <td>0x59</td>
            <td>Y</td>
            <td>121</td>
            <td>0x79</td>
            <td>y</td>
          </tr>
          <tr>
            <td>26</td>
            <td>0x1A</td>
            <td>SUB</td>
            <td>58</td>
            <td>0x3A</td>
            <td>:</td>
            <td>90</td>
            <td>0x5A</td>
            <td>Z</td>
            <td>122</td>
            <td>0x7A</td>
            <td>z</td>
          </tr>
          <tr>
            <td>27</td>
            <td>0x1B</td>
            <td>ESC</td>
            <td>59</td>
            <td>0x3B</td>
            <td>;</td>
            <td>91</td>
            <td>0x5B</td>
            <td>[</td>
            <td>123</td>
            <td>0x7B</td>
            <td>{</td>
          </tr>
          <tr>
            <td>28</td>
            <td>0x1C</td>
            <td>FS</td>
            <td>60</td>
            <td>0x3C</td>
            <td>&lt;&nbsp;</td>
            <td>92</td>
            <td>0x5C</td>
            <td>\</td>
            <td>124</td>
            <td>0x7C</td>
            <td>|</td>
          </tr>
          <tr>
            <td>29</td>
            <td>0x1D</td>
            <td>GS</td>
            <td>61</td>
            <td>0x3D</td>
            <td>=</td>
            <td>93</td>
            <td>0x5D</td>
            <td>]</td>
            <td>125</td>
            <td>0x7D</td>
            <td>}</td>
          </tr>
          <tr>
            <td>30</td>
            <td>0x1E</td>
            <td>RS</td>
            <td>62</td>
            <td>0x3E</td>
            <td>&gt;&nbsp;</td>
            <td>94</td>
            <td>0x5E</td>
            <td>^</td>
            <td>126</td>
            <td>0x7E</td>
            <td>~</td>
          </tr>
          <tr>
            <td>31</td>
            <td>0x1F</td>
            <td>US</td>
            <td>63</td>
            <td>0x3F</td>
            <td>?</td>
            <td>95</td>
            <td>0x5F</td>
            <td>_</td>
            <td>127</td>
            <td>0x7F</td>
            <td>DEL</td>
          </tr>
        </tbody>
      </table>
      <h3>2진법과 16진법</h3>
      <ul><span id="ulh">2진법</span>
        <li>컴퓨터는 전압을 높이거나 낮추는 전기신호를 통해 0과 1을 표현한다. 이것이 디지털 2진법이다 </li>
        <li>2진법 1자리는 1bit 이다 </li>
        <li>2진법 4자리는 1nibble 이다 </li>
        <li>2진법 8자리는 1byte 이다 </li>
      </ul>
      <ul><span id="ulh">16진법</span>
        <li>16진법은 한 자리에 0~15까지 표현한다 (0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f) </li>
        <li>2진법 4자리 <span id="accent">1111</span> = 16진법 1자리 <span id="accent">0xf</span></li>
        <li>16진법 1자리는 4bit = 1nibble 이다 </li>
        <li>16진법 2자리는 1byte 이다 </li>
        <li>64비트 운영체제는 8byte 이고 16진법 16자리이다 </li>
      </ul>


      <h3>문자_서식지정자</h3>
      <ul><span id="ulh"></span>
        <li>%c : character <span id="comment">→ 문자형태로 출력</span></li>
        <li>%d : decimal(10진수)<span id="comment">→ char 변수에 저장된 10진수정숫값(ASCII 코드값)이 출력</span></li>
        <li>0x%x : hexadecimal(16진수) <span id="comment">→10진수와구분하기위해 보통 서식지정자 앞에 0x를 붙여 0xf형태로 출력</span></li>
        <li>0x%X : 16진수의 알파벳을 대문자로 표시 0xF</li>
      </ul>

      <h3>'0' 과 0</h3>
      <ul><span id="ulh">char 변수에 문자'0'을 할당</span>
        <li>%c <span id="comment">→0</span></li>
        <li>%d <span id="comment">→ASCII 코드값인 48</span></li>
      </ul>
      <ul><span id="ulh">char 변수에 정수0을 할당</span>
        <li>%c <span id="comment">→미출력(NULL)</span></li>
        <li>%d <span id="comment">→ASCII 코드값인 0</span></li>
      </ul>

      <h3>문자_연산</h3>
      <p>문자는 ASCII 코드 규칙에 의해 정수로 저장되므로 정수처럼 덧셈, 뺄셈 등을 할 수 있습니다.a의 ASCII 코드값은 97이고 1을 더하면 98입니다. 따라서 98에 해당하는 문자 b가
        출력됩니다.
        <br>변수,문자,정수 어떤 값으로 사칙연산을 하느냐에 상관없이 결과값이 0~255 사이의 ASCII 코드 범위에만 있으면 됩니다.
      </p>

      <h3>문자_제어문자</h3>
      <p>
      <table border="1">
        <th>이름</th>
        <th>표기법</th>
        <th>10진수</th>
        <th>16진수</th>
        <th>%c출력</th>
        <tr>
          <td>LF(Line Feed)</td>
          <td>\n</td>
          <td>10</td>
          <td>0x0A</td>
          <td>줄바꿈</td>
        </tr>
        <tr>
          <td>CR(Carriage Return)</td>
          <td>\r</td>
          <td>13</td>
          <td>0x0D</td>
          <td>줄의 끝에서 시작 위치로 되돌아감</td>
        </tr>
        <tr>
          <td>TAB(horizontal tab)</td>
          <td>\t</td>
          <td>9</td>
          <td>0x09</td>
          <td>일정 크기만큼 공간을 띄움</td>
        </tr>
      </table>
      </p>


      <h2>실수 (float, double, long double)</h2>
      <p>우리는 실생활에서 1과 1.0을 구분하지 않지만 컴퓨터는 1과 1.0을 정수와 실수로 구분합니다. 마찬가지로 C 언어는 컴퓨터를 제어하는 언어라 정수와 실수를 구분합니다. 따라서 여러분들은 이 부분만
        기억하면 되고, 자신이 표현할 데이터가 정수인지 실수인지만 구분할 수 있으면 됩니다.</p>
      <p>실수의 방식은 두가지가 있는데, 지수 표기법은 실수를 소스 코드에 표기하거나 화면에 출력하는 방법이며 부동소수점 방식은 실수를 메모리 또는 디스크에 저장하는 방식입니다. 유효자리를 저장할때는 반올림이
        기본입니다.</p>
      <table border="1">
        <thead>
          <th>자료형</th>
          <th>크기</th>
          <th>범위</th>
          <th>유효자릿수</th>
          <th>비고</th>
        </thead>
        <tbody>
          <tr>
            <td>float</td>
            <td>4바이트, <br>32비트 </td>
            <td>1.175494e-38~3.402823e+38</td>
            <td>7</td>
            <td>IEEE 754 단정밀도 부동소수점</td>
          </tr>
          <tr>
            <td>double</td>
            <td>8바이트, <br>64비트</td>
            <td>2.225074e-308~1.797693e+308</td>
            <td>16</td>
            <td>IEEE 754 배정밀도 부동소수점</td>
          </tr>
          <tr>
            <td>long <br>double</td>
            <td>8바이트, <br>64비트</td>
            <td>2.225074e-308~1.797693e+308</td>
            <td>16</td>
            <td>IEEE 754 배정밀도 부동소수점</td>
          </tr>
        </tbody>
      </table>

      <h3>실수_입력방법</h3>
      <p>소수점 앞 또는 뒤의 0은 생략할 수 있습니다.</p>
      <ul><span id="ulh">부동소수점</span>
        <li>float는 숫자 뒤에 f 혹은 F를 붙임<span id="comment"> float n1 = 0.1f;</span></li>
        <li>double은 숫자 뒤에 아무것도 붙이지 않음<span id="comment"> double n2 = 3243.213422;</span></li>
        <li>long double은 숫자 뒤에 l 혹은 L을 붙임<span id="comment"> long double n3 = 9.324312l;</span></li>
      </ul>

      <ul><span id="ulh">지수표기법</span>
        <li>자료형 크기에 맞게 마지막에 f 또는 l을 붙여줍니다.</li>
        <li>정수 부분은 한 자릿수만 적고, 뒤에 e지수 표기<span id="comment"> float n1 = 3.e5f; (300000.0)</span></li>
        <li>e 뒤에 지수가 양수이면 소수점 기준으로 자릿수가 왼쪽으로 이동하며 음수이면 오른쪽으로 이동합니다. 지수가 양수일 때는 +를 생략할 수 있습니다<span id="comment"> float n1 =
            -3.324e-2f; (-0.03324)</span></li>
      </ul>


      <h3>실수_서식지정자</h3>
      <ul><span id="ulh">부동소수점</span>
        <li>%f : floating point(부동소수점) <span id="comment">→ float, double</span></li>
        <li>%Lf : long floating point <span id="comment">→ long double</span></li>
      </ul>
      <ul><span id="ulh">지수표기법</span>
        <li>%e : exponential notation(지수표기법) <span id="comment">→ float, double</span></li>
        <li>%Le : long exponential notation <span id="comment">→ long double</span></li>
        <li>%.nf : 소수점아래 n자리표기 <span id="comment">지정하지않으면 기본6자리표기</span></li>
      </ul>

      <h3>실수_최대최소(float.h)</h3>
      <p>float.h 헤더 파일에 각 자료형 별로 양수 최솟값과 최댓값이 정의되어 있습니다.</p>
      <table border="1">
        <thead>
          <tr>
            <th>자료형</th>
            <th>크기</th>
            <th>범위</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>float</td>
            <td>FLT_MIN</td>
            <td>FLT_MAX</td>
          </tr>
          <tr>
            <td>double</td>
            <td>DBL_MIN</td>
            <td>DBL_MAX</td>
          </tr>
          <tr>
            <td>long double</td>
            <td>LDBL_MIN</td>
            <td>LDBL_MAX</td>
          </tr>
        </tbody>
      </table>

      <h3>실수 오버플로우&언더플로우</h3>
      <p>C 언어에서는 양의실수 언더플로우를 0 또는 쓰레기 값으로 처리합니다. 오버플로우는 최솟값으로 되돌아가지 않고 무한대(infinity) inf가 출력됩니다.</p>
      <ul>
        <li>+MAX 보다 더 커지면 inf</li>
        <li>+MIN 보다 더 작아지면 0</li>
        <li>-MAX 보다 더 커지면 0</li>
        <li>-MAX 보다 더 커지면 -inf</li>
      </ul>
      <p><img src="C언어_실수오버플로우.JPG" border="1" width="600px"></p>


      <h2>상수 (const)</h2>
      <p>상수는 변하지 않는 값을 뜻합니다. 변수는 한 번 선언한후 계속 다른값을 선언할 수 있지만, 상수는 처음 선언할 때만 값을 할당할 수 있으며 그 다음부터는 상수를 선언하면 에러가 발생한다. 즉 상수는
        선언과 동시에 값을 할당하는 초기화로만 선언가능하다. 방식은 변수 앞에 const만 덧붙이면 된다.</p>


      <h3>상수_리터럴(literal)</h3>
      <p>리터럴(literal)은 "문자 그대로"라는 뜻인데 C 언어에서는 값 그자체를 의미합니다. 변수에 저장하지 않고 10, 0.1f, 'a', "Hello, world!"처럼 값을 그대로 입력한 것이
        리터럴입니다. 그리고 상수(constant)는 변수와같이 리터럴이 저장된 공간입니다. 리터럴은 반드시 표기 방법을 지켜야 합니다.
      </p>
      <ul><span id="ulh">문자 입력방법</span>
        <li>문자는 반드시 작은따옴표로 묶어주어야 하고, 문자열은 큰따옴표로 묶어줍니다. 문자나 문자열을 따옴표로 묶어주지 않으면 변수, 함수 등으로 인식되므로 주의합니다.</li>
      </ul>
      <ul><span id="ulh">정수 입력방법</span>
        <li>10진수는 숫자 그대로 표기하면 되고, 8진수는 숫자 앞에 0을 붙이고, 16진수는 0x를 붙입니다</li>
      </ul>
      <ul><span id="ulh">실수 입력방법</span>
        <li>실수자료형과 동일</li>
      </ul>

      <h3>상수_리터럴접미사</h3>
      <p>리터럴의 크기를 명확하게 표현하기 위해 접미사(suffix)를 사용한다. 상수값 뒤에 접미사를 붙여쓴다.
        <br>접미사는 대소문자를 모두 사용할 수 있으며, 정수는 10진수, 8진수, 16진수에도 접미사를 사용할 수 있다.
      </p>

      <table border="1">
        <thead>
          <tr>
            <th>접미사</th>
            <th>정수자료형</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>생략</td>
            <td>int</td>
          </tr>
          <tr>
            <td>l, L</td>
            <td>long</td>
          </tr>
          <tr>
            <td>u, U</td>
            <td>unsigned int</td>
          </tr>
          <tr>
            <td>ul, UL</td>
            <td>unsigned long</td>
          </tr>
          <tr>
            <td>ll, LL</td>
            <td>long long</td>
          </tr>
          <tr>
            <td>ull, ULL</td>
            <td>unsigned long long</td>
          </tr>
          <tr>
            <th>접미사</th>
            <th>실수자료형</th>
          </tr>
          <tr>
            <td>f, F</td>
            <td>float</td>
          </tr>
          <tr>
            <td>생략</td>
            <td>double</td>
          </tr>
          <tr>
            <td>l, L</td>
            <td>long double</td>
          </tr>
        </tbody>
      </table>


      <h2>사용자 입력받기(scanf)</h2>
      <p>사용자에게 표준입력으로 입력을 받고자 할때는 scanf 함수를 사용한다</p>
      <ul>
        <li>scanf("서식지정자", &변수); <span id="comment">→변수 앞 &주의</span></li>
        <li>char c1 = getchar(); // putchar(c1); <span id="comment">→문자 하나를 입력받고 출력할때 사용</span> </li>
      </ul>


      <h1>연산</h1>
      <h2>산술연산</h2>
      <br>
      <table border="1">
        <thead>
          <tr>
            <th colspan="2">연산자</th>
            <th>설명</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td colspan="2">+</td>
            <td>덧셈</td>
          </tr>
          <tr>
            <td colspan="2">-</td>
            <td>뺄셈</td>
          </tr>
          <tr>
            <td colspan="2">*</td>
            <td>곱셈</td>
          </tr>
          <tr>
            <td colspan="2">/</td>
            <td>나눗셈</td>
          </tr>
          <tr>
            <td colspan="2">%</td>
            <td>나머지(정수를 나눈 뒤 나머지만 구함)</td>
          </tr>
          <tr>
            <td colspan="2">+=</td>
            <td>덧셈 후 할당</td>
          </tr>
          <tr>
            <td colspan="2">-=</td>
            <td>뺄셈 후 할당</td>
          </tr>
          <tr>
            <td colspan="2">*=</td>
            <td>곱셈 후 할당</td>
          </tr>
          <tr>
            <td colspan="2">%=</td>
            <td>나머지를 구한 후 할당</td>
          </tr>
          <tr>
            <td rowspan="2">전위</td>
            <td>++변수</td>
            <td>변수 = ++변수; 1증가 후 할당</td>
          </tr>
          <tr>
            <td>--변수</td>
            <td>변수 = --변수; 1감소 후 할당</td>
          </tr>
          <tr>
            <td rowspan="2">후위</td>
            <td>변수++</td>
            <td>변수 = 변수++; 할당 후 1증가</td>
          </tr>
          <tr>
            <td>변수--</td>
            <td>변수 = 변수--; 할당 후 1감소</td>
          </tr>
        </tbody>
      </table>

      <h3>사칙연산</h3>
      <ul><span id="ulh"></span>
        <li>num1 = num1 + 2; (num1 += 2;) <span id="comment">→변수이름이 동일하게 쓰이는 부분 주의</span></li>
        <li>num1 = num1 - 2; (num1 -= 2;)</li>
        <li>num1 = num1 * 2; (num1 *= 2;)</li>
        <li>num1 = num1 / 2; (num1 /= 2;) <span id="comment">→정수,실수 자료형에 따라 결과값이 나옴</span></li>
        <li>일반적으로 0으로 나누면 에러가 발생하지만, 실수0으로 나누면 inf값이 나온다</li>
      </ul>

      <h3>나머지연산</h3>
      <p>나눗셈 후 몫을 제외한 나머지를 구하는 연산, 정수에서만 사용가능하다</p>
      <ul><span id="ulh"></span>
        <li>%</li>
        <li>num1 = num1 % 2; (num1 %= 2;)</li>
      </ul>


      <h3>증감연산자</h3>
      <ul><span id="ulh">증감연산자</span>
        <li>num1++;(++num1;) 1증가 <span id="comment">→단독사용시에는 위치에 큰 차이 없음</span></li>
        <li>num1--;(--num1;) 1감소</li>
      </ul>
      <ul><span id="ulh">후위postfix연산자</span>
        <li>증감 연산자를 변수 뒤에 사용한 것</li>
        <li>변수 = num1++; <span id="comment">→num1의 값을 변수에 할당한 뒤 num1의 값을 1 증가시킴</span></li>
      </ul>
      <ul><span id="ulh">전위prefix연산자</span>
        <li>증감 연산자를 변수 앞에 사용한 것</li>
        <li>변수 = ++num1; <span id="comment">→num1의 값을 1 증가시킨 뒤 변 에 할당</span></li>
      </ul>



      <h2>논리연산</h2>
      <h3>비교연산자</h3>
      <p>조건식에서 비교할 때 사용, 참이면 0이아닌모든값/ 거짓이면 0
      <table border="1">
        <thead>
          <tr>
            <th>연산자</th>
            <th>설명</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>==</td>
            <td>같음</td>
          </tr>
          <tr>
            <td>!=</td>
            <td>같지 않음(다름)</td>
          </tr>
          <tr>
            <td>&gt;</td>
            <td>큼</td>
          </tr>
          <tr>
            <td>&lt;</td>
            <td>작음</td>
          </tr>
          <tr>
            <td>&gt;=</td>
            <td>크거나 같음</td>
          </tr>
          <tr>
            <td>&lt;=</td>
            <td>작거나 같음</td>
          </tr>
        </tbody>
      </table>
      </p>

      <h3>논리연산자</h3>
      <p>조건식을 판단할 때 주로 사용, 참이면 0이아닌모든값/ 거짓이면 0
        <br>단락 평가(short-circuit evalution)는 첫 번째 값만으로 결과가 확실할 때 두 번째 값은 평가하지 않는 방법으로 AND연산자와 OR연산자에 적용된다
      <table border="1">
        <thead>
          <tr>
            <th>연산자</th>
            <th>설명</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>&amp;&amp;</td>
            <td>AND(논리곱), 양쪽 모두 참일 때만 참(0은 무엇과 곱해도0)</td>
          </tr>
          <tr>
            <td>||</td>
            <td>OR(논리합), 양쪽 중 한쪽만 참이라도 참</td>
          </tr>
          <tr>
            <td>!</td>
            <td>NOT(논리 부정), 참과 거짓을 뒤집음</td>
          </tr>
        </tbody>
      </table>
      </p>

      <h3>boolean 자료형(stdbool.h)</h3>
      <p>bool 변수 = true/false;
        <br>전용 서식지정자는 없으므로 숫자나 문자열로 출력해야한다
        <br>int의 크기는 4바이트, bool의 크기는 1바이트
      </p>


      <h2>단항,이항,삼항 연산자</h2>
      <ul>
        <li>단항연산자 : 변수1개 (예시 증감연산자 A++)</li>
        <li>이항연산자 : 변수2개 (예시 사칙연산자A + B, 할당연산자 A = B)</li>
        <li>삼항연산자 : <span id="accent">X ? A : B</span> (X가 참이면 A반환 거짓이면 B반환)</li>
      </ul>


      <h2>비트연산자</h2>
      <p>비트 연산자는 바이트 단위보다 더 작은 비트단위(2진수)로 연산하는 연산자입니다.
        <br>각 자리 수의 연산은 독립적이며 다른 자리 수에 영향을 주지 않습니다.
        <br>비트의 최대 자리수는 선언되는 자료형의 최대 비트수로 결정된다.
      </p>
      <ul><span id="ulh"> Bit 와 Byte</span>
        <li>Bit : 컴퓨터 최소 단위. 0과 1의 2진수를 저장한다</li>
        <li>Byte : 8비트 = 1바이트</li>
      </ul>
      <br>
      <table border="1">
        <thead>
          <tr>
            <th>연산자</th>
            <th>설명</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>&amp;</td>
            <td>비트AND, 모두 1일때 1</td>
          </tr>
          <tr>
            <td>|</td>
            <td>비트OR, 하나라도 1이면 1</td>
          </tr>
          <tr>
            <td>^</td>
            <td>비트XOR(Exclusive OR), 두 비트가 같으면 0 다르면 1</td>
          </tr>
          <tr>
            <td>~</td>
            <td>비트NOT, 0은 1로 1은 0으로 비트반전</td>
          </tr>
          <tr>
            <td>&lt;&lt; n</td>
            <td>시프트, 비트를 왼쪽으로 n칸이동 (왼쪽끝삭제 오른쪽끝0추가)</td>
          </tr>
          <tr>
            <td>&gt;&gt; n</td>
            <td>시프트, 비트를 오른쪽으로 n칸이동 (오른쪽끝삭제 왼쪽끝0추가)</td>
          </tr>
          <tr>
            <td>&amp;=</td>
            <td>비트 AND 연산 후 할당</td>
          </tr>
          <tr>
            <td>|=</td>
            <td>비트 OR 연산 후 할당</td>
          </tr>
          <tr>
            <td>^=</td>
            <td>비트 XOR 연산 후 할당</td>
          </tr>
          <tr>
            <td>&lt;&lt;=</td>
            <td>비트를 왼쪽으로 시프트한 후 할당</td>
          </tr>
          <tr>
            <td>&gt;&gt;=</td>
            <td>비트를 오른쪽으로 시프트한 후 할당</td>
          </tr>
        </tbody>
      </table>


      <h3>비트연산자_부호있는자료형</h3>
      <p>비트 연산자는 부호 있는 자료형과 부호 없는 자료형이 다르게 동작합니다. 부호 있는 자료형의 첫 번째 비트는 부호 비트라고 하는데 이 비트가 1이면 음수, 0이면 양수입니다.</p>
      <ul><span id="ulh"> >>연산 </span>
        <li>부호있는자료형 - : 왼쪽끝을 1로 채우며 이동</li>
        <li>부호있는자료형 + : 왼쪽끝을 0으로 채우며 이동</li>
        <li>부호'없'는자료형 : 왼쪽끝을 0으로 채우며 이동</li>
      </ul>
      <ul><span id="ulh">
          <<연산 </span>
            <li>부호있는자료형 - : 오른쪽끝을 0으로 채우며 이동</li>
            <li>부호있는자료형 + : 오른쪽끝을 0으로 채우며 이동</li>
            <li>부호'없'는자료형 : 오른쪽끝을 0으로 채우며 이동</li>
      </ul>


      <h3>Flag</h3>
      <p>비트가 1= on, 0 = off
        <br>플래그로 사용할 변수에 할당연산자와 숫자(mask)를 사용하여 특정 비트를 조작하거나 검사할 수 있다.
      </p>
      <ul><span id="ulh">플래그 조작</span>
        <li>flag |= mask <span id="comment">ON 하나라도1이면1이니깐 마스크비트자리가 1됨=켜짐</span></li>
        <li>flag &= ~mask <span id="comment">OFF ~마스크자리는 0이되고 모두1이라야1이니깐 해당자리 0됨=꺼짐 </span></li>
        <li>flag ^= mask <span id="comment">Toggle 마스크자리가1이므로 1일땐 0되고 0일땐 1이1됨</span></li>
      </ul>
      <ul><span id="ulh">플래그 검사</span>
        <li>if (flag & mask) <span id="comment">모두1이라야1이니깐 켜져있으면1 꺼져있으면0</span></li>
      </ul>


      <h2>연산자 우선순위</h2>
      <p>수학에서 덧셈보다 곱셈을 먼저하듯이 C언어의 연산자에도 우선순위가 있다.
        <br>낮은우선순위의 연산자를 우선으로 연산하고자 할 때는 괄호를 사용한다.
        <br>연산자 우선순위가 신경쓰이면 무조건 괄호를 사용하세요. 우선순위를 따져가며 읽어야 되는 코드보다는 괄호가 많더라도 의도가 명확한 코드가 좋습니다.
        <br><span id="accent">연산순서 : 1.괄호 → 2.연산자의우선순위 → 3.결합법칙방향</span>
      </p>

      <table border="1">
        <thead>
          <tr>
            <th>우선순위</th>
            <th>연산자</th>
            <th>설명</th>
            <th>결합 법칙(방향)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>1<br><br><br><br><br></td>
            <td>X++<br>X--<br>( )<br>[ ]<br>.<br>-&gt;<br>(자료형){값}</td>
            <td>증가 연산자(뒤, 후위)<br>감소 연산자(뒤, 후위)<br>함수 호출<br>배열 첨자<br>구조체/공용체 멤버 접근<br>포인터로 구조체/공용체 멤버 접근<br>복합 리터럴</td>
            <td>→<br><br><br><br><br></td>
          </tr>
          <tr>
            <td>2<br><br><br><br><br><br><br><br><br><br></td>
            <td>++X<br>--X<br>+X<br>-X<br>!<br>~<br>(자료형)<br>*X<br>&amp;X<br>sizeof</td>
            <td>증가 연산자(앞, 전위)<br>감소 연산자(앞, 전위)<br>단항 덧셈(양의 부호)<br>단항 뺄셈(음의 부호)<br>
              논리 NOT<br>비트 NOT<br>자료형 캐스팅(자료형 변환)<br>포인터 X 역참조<br>X의 주소<br>자료형의 크기<br></td>
            <td>←<br><br><br><br><br><br><br><br><br><br><br></td>
          </tr>
          <tr>
            <td>3<br><br><br></td>
            <td>*<br>/<br>%</td>
            <td>곱셈<br>나눗셈<br>나머지</td>
            <td>→<br><br><br></td>
          </tr>
          <tr>
            <td>4<br><br></td>
            <td>+<br>-</td>
            <td>덧셈<br>뺄셈</td>
            <td>→<br><br></td>
          </tr>
          <tr>
            <td>5<br><br></td>
            <td>&lt&lt;<br>&gt&gt;</td>
            <td>비트를 왼쪽으로 시프트<br>비트를 오른쪽으로 시프트</td>
            <td>→<br><br></td>
          </tr>
          <tr>
            <td>6<br><br><br><br></td>
            <td>&lt;<br>&lt;=<br>&gt;<br>&gt;=</td>
            <td>작음<br>작거나 같음<br>큼<br>크거나 같음</td>
            <td>→<br><br><br><br></td>
          </tr>
          <tr>
            <td>7<br><br></td>
            <td>==<br>!=</td>
            <td>같음<br>다름</td>
            <td>→<br><br></td>
          </tr>
          <tr>
            <td>8</td>
            <td>&amp;</td>
            <td>비트 AND곱</td>
            <td>→</td>
          </tr>
          <tr>
            <td>9</td>
            <td>^</td>
            <td>비트 XOR</td>
            <td>→</td>
          </tr>
          <tr>
            <td>10</td>
            <td>|</td>
            <td>비트 OR합</td>
            <td>→</td>
          </tr>
          <tr>
            <td>11</td>
            <td>&amp;&amp;</td>
            <td>논리 AND곱</td>
            <td>→</td>
          </tr>
          <tr>
            <td>12</td>
            <td>||</td>
            <td>논리 OR합</td>
            <td>→</td>
          </tr>
          <tr>
            <td>13</td>
            <td>? :</td>
            <td>삼항 연산자</td>
            <td>←</td>
          </tr>
          <tr>
            <td>14<br><br><br><br><br><br><br><br><br><br><br><br></td>
            <td>=<br>+=<br>-=<br>*=<br>/=<br>%=<br>&lt;&lt;=<br>&gt;&gt;=<br>&amp;=<br>^=<br>|=<br></td>
            <td>할당<br>덧셈 후 할당<br>뺄셈 후 할당<br>곱셈 후 할당<br>나눗셈 후 할당<br>나머지 연산 후 할당<br>비트를 왼쪽으로 시프트한 후 할당<br>비트를 오른쪽으로 시프트한 후
              할당<br>비트 AND 연산 후 할당<br>비트 XOR 연산 후 할당<br>비트 OR 연산 후 할당<br></td>
            <td>←<br><br><br><br><br><br><br><br><br><br><br><br></td>
          </tr>
          <tr>
            <td>15</td>
            <td>,</td>
            <td>쉼표(콤마) 연산자</td>
            <td>→</td>
          </tr>
        </tbody>
      </table>



      <h1>조건문과 반복문</h1>
      <h2>조건문</h2>
      <h3>If 조건문</h3>
      <p>if 조건문에서 조건의 결과값은 참/거짓으로 나타나고, 참일 때 실행 할 코드 거짓일 때 실행 할 코드를 지정한다. <span id="comment">할당연산자= 와 같다== 를 구분할 것</span></p>
      <ul><span id="ulh">If</span>
        <li><span id="accent">if (조건식) {코드; 코드;(중첩가능)}</span> 조건식 뒤에 세미콜론;을 붙이면 뒷코드와 분리되어 참거짓 유무와 상관없이 항상 실행되므로 주의할 것</li>
        <li><span id="accent">if (조건식) 코드;</span> 코드가 한개일때는 중괄호 생략가능</li>
      </ul>
      <ul><span id="ulh">If + else if(중첩가능) + else(생략가능)</span>
        <li><span id="accent">if (조건식) {코드;} else if (조건식) {코드;} else if (조건식) {코드;} else {코드;}</span></li>
      </ul>


      <h3>Swith 분기문</h3>
      <p>switch 분기문에서 조건에는 변수가 들어가며(조건식불가), 다수의 리터럴값에 다수의 case를 매칭한다.</p>
      <ul><span id="ulh">swith + case(중첩가능) + default(생략가능)</span>
        <li><span id="accent">swith(변수) {case 리터럴값: 코드; break; case 리터럴값: 코드; break; default: 코드; break;}</span></li>
        <li>break를 사용하지 않으면 해당하지 않는 case가 모두 실행된다. fall through (default 뒤의 break는 생략해도 결과가 같다.)</li>
      </ul>
      <ul><span id="ulh">자료형태</span>
        <li>swith뒤는 변수, case뒤는 리터럴 값이 온다.</li>
        <li>swith와 case의 자료형은 정수,문자자료형이 온다. <i>실수,문자열X</i></li>
      </ul>


      <h2>반복문</h2>
      <p><span id="accent">조건식이 '참'일때 반복실행, 거짓이 되면 반복종료</span></p>
      <h3>For 반복문</h3>
      <p>반복횟수가 정해져있을 때 주로 사용. 조건식이 참일때 변화식을 실행하면서 코드를 실행. 조건식이 거짓이되면 반복멈춤
        <br>순환하는 부분인 루프(loop)는 조건식 → 루프 본체 → 변화식 → 조건식 이다.
      </p>
      <ul><span id="ulh">for (초기식; 조건식; 변화식) {코드}</span>
        <li><span id="accent">for (초기식; 조건식; 변화식)</span> ←루프 선언문(loop statement)</li>
        <li><span id="accent">{코드}</span> ←루프 본체(loop body)</li>
      </ul>
      <ul><span id="ulh">기타사항</span>
        <li>변화식에서 ++i는 i증가하고 코드실행 , i++는 코드실행 후 i증가</li>
        <li>변화식에는 ++, --뿐만 아니라 +=, -=, *=, /=도 사용</li>
        <li>이미 선언된 변수를 사용할때는 i를 따로 사용하지 않고, 초기식 부분을 생략할 수 있다.</li>
        <li>for (;;) <span id="comment"> 초깃값, 조건식, 변화식을 모두 생략하면 무한 루프</span></li>
        <li>코드가 한줄일때는 중괄호를 생략할 수 있다</li>
      </ul>

      <h3>While 반복문</h3>
      <p>반복 횟수가 정해지지 않았을 때, 논리 조건에 따라 반복 여부를 결정할 때 주로 사용.
        <br>루프(loop)는 조건식 → 루프 본체 및 변화식 → 조건식 이다.
      </p>
      <ul><span id="ulh">초기식; while(조건식) {코드;변화식;}</span>
        <li><span id="accent">초기식; while(조건식)</span> ←루프 선언문(loop statement)</li>
        <li><span id="accent">{코드;변화식;}</span> ←루프 본체(loop body)</li>
      </ul>
      <ul><span id="ulh">기타사항</span>
        <li>while (숫자) <span id="comment">해당 숫자만큼 반복된다</span></li>
        <li>while (1) 혹은 while (true) <span id="comment">무한 루프</span></li>
      </ul>

      <h3>Do while 반복문</h3>
      <p>초기식의 값과는 상관 없이 do코드를 최소 한 번은 실행
        <br>루프(loop)는 루프 본체 및 변화식 → 조건식 이다.
      </p>
      </p>
      <ul><span id="ulh">초기식; do {코드;변화식;} while(조건식);</span>
        <li><span id="accent">do {코드;변화식;}</span> ←루프 선언문(loop statement)</li>
        <li><span id="accent">while(조건식);</span> ←루프 본체(loop body)</li>
      </ul>
      <ul><span id="ulh">기타사항</span>
        <li>while (1) <span id="comment">무한 루프</span></li>
        <li>while (0) <span id="comment">코드 한 번만 실행 (매크로에서사용)</span></li>
      </ul>


      <h3>중첩Loop</h3>
      <p>반복문 안에 반복문을 넣어 행열을 통제할 수 있다. 관습적으로 변수는 i,j,k 순서로 쓴다
        <br><img src="C언어_반복문For중첩.JPG" border="1">
      </p>


      <h2>Break와 Continue</h2>
      <p>break는 반복을 중단하고 빠져 나오는 역할
        <br>continue는 반복흐름을 유지한 상태에서 뒤에 위치한 코드의 실행만 건너뛰는 역할
      </p>
      <ul><span id="ulh">사용형태</span>
        <li>반복문안에서 if조건식과 힘께 반복문을 컨트롤 할 수 있다</li>
        <li>swith 조건문안에서 case와 함께 break;를 쓰면 다수의case에 하나의코드를 실행하도록 매칭할 수 있다</li>
      </ul>


      <h2>goto 제어문</h2>
      <p>goto는 별다른 제약 조건 없이 원하는 레이블로 이동
        <br>스파게티 코드는 goto를 과도하게 사용해서 프로그램의 흐름이 마치 스파게티 면발처럼 꼬여있다는데서 붙여진 이름입니다. 그래서 스파게티 코드는 가독성이 떨어지고 유지보수가 매우 힘듭니다.
      </p>
      <ul><span id="ulh">레이블생성</span>
        <li>레이블명: 코드; 코드; 코드;</li>
      </ul>
      <ul><span id="ulh">goto</span>
        <li>goto 레이블명;</li>
        <li>이동한 레이블부터 순서대로 코드실행, 다음레이블의 코드도 실행된다</li>
      </ul>


      <h1>배열과 포인터</h1>
      <h2>배열</h2>
      <p>배열은 여러개의 값을 담은 변수</p>
      <h3>배열의선언</h3>
      <ul><span id="ulh">선언</span>
        <li><span id="accent">자료형 배열[크기];</span> 크기생략불가</li>
        <li><span id="accent">자료형 배열[크기] = { 값, 값, 값 };</span> 크기생략가능</li>
        <li>{ }를 사용하여 배열에 값을 할당하는 방법은 배열을 선언할 때만 사용할 수 있으며 이미 선언된 배열에는 사용할 수 없습니다.</li>
      </ul>
      <ul><span id="ulh">초기화</span>
        <li>자료형 배열[크기] = { 0, };</li>
      </ul>

      <h3>배열의접근</h3>
      <p>배열에 값이 저장된 공간을 요소(element)라고 하며, 배열의 요소에 접근할 때 인덱스로 음수를 지정하거나, 배열의 크기를 벗어난 인덱스를 지정해도 컴파일 에러가 발생하지 않습니다. 하지만 실행을
        해보면 쓰레기값이 출력됩니다. 즉, 배열의 범위를 벗어난 인덱스에 접근하면 배열이 아닌 다른 메모리 공간에 접근하게 됩니다.</p>
      <ul><span id="ulh">접근</span>
        <li><span id="accent">배열[인덱스];</span></li>
      </ul>
      <ul><span id="ulh">요소할당</span>
        <li><span id="accent">배열[인덱스] = 값;</span> 해당 인덱스 요소에 값을 새로 할당(수정)</li>
      </ul>
      <ul><span id="ulh">요소갯수 계산하기</span>
        <li>sizeof(배열) / sizeof(int)</li>
      </ul>


      <h3>2차원 배열</h3>
      <p>2차원 배열은 세로x가로 평면 구조로 이루어져 있으며 행과 열 모두 0부터 시작합니다.
        <br><img src="C언어_배열2차원.JPG" width="600" border="1">
      </p>
      <ul><span id="ulh">선언</span>
        <li><span id="accent">자료형 배열[세로크기][가로크기];</span></li>
        <li><span id="accent">자료형 배열[세로크기][가로크기] = { { 값, 값, 값 }, {값, 값, 값} };</span></li>
        <li>int 배열[2][4] = { { 가로요소4개 }, { 가로요소4개 } };</li>
      </ul>
      <ul><span id="ulh">초기화</span>
        <li>자료형 배열[세로크기][가로크기] = { 0, };</li>
      </ul>
      <ul><span id="ulh">접근</span>
        <li><span id="accent">배열[세로인덱스][가로인덱스];</span></li>
      </ul>
      <ul><span id="ulh">요소할당</span>
        <li><span id="accent">배열[세로인덱스][가로인덱스]; = 값;</span></li>
      </ul>
      <ul><span id="ulh">요소갯수 계산하기</span>
        <li>int row<span id="comment">세로몇줄인지</span> = sizeof(배열)<span id="comment">전체크기</span> / sizeof(배열[0])<span
            id="comment">가로첫줄크기</span>;</li>
        <li>int col<span id="comment">가로요소갯수</span> = sizeof(배열[0])<span id="comment">가로첫줄크기</span> / sizeof(자료형);</li>
      </ul>

      <h3>3차원배열</h3>
      <p>자료형 배열[높이][세로크기][가로크기];
        <br><img src="C언어_배열3차원.JPG" width="600" border="1">
      </p>


      <h2>포인터(pointer)</h2>
      <p>변수는 컴퓨터의 메모리에 생성되며 메모리 주소는 고정된 것이 아니라 컴퓨터마다, 실행할 때마다 달라집니다. C언어에서는 메모리 주소도 데이터로 취급하는데, 이 주소정보를 담은 자료형을 포인터라고하며
        모든 자료형에 *를 붙여 포인터자료형으로 선언할 수 있다.
        <br>& 주소연산자는 데이터의 시작주소를 나타낸다. 주소는 16진수로 저장되고 음수는 존재하지 않는다
      </p>
      <h3>기본선언</h3>
      <ul><span id="ulh">선언</span>
        <li><span id="accent">int* 포인터;</span> 포인터자료형의 변수선언</li>
        <li><span id="accent">int* 포인터 = &변수;</span> 선언과할당</li>
      </ul>
      <ul><span id="ulh">할당</span>
        <li><span id="accent">포인터 = &변수;</span> 포인터는 변수의 주소만 가리킴</li>
      </ul>
      <ul><span id="ulh">역참조</span>
        <li><span id="accent">*포인터 = 변수/값;</span> 역참조는 주소에 접근하여 값을 가져오거나 저장</li>
      </ul>
      <p><img src="C언어_포인터.JPG" width="600" border="1"></p>


      <h3>동적메모리할당 선언</h3>
      <p>동적메모리할당(dynamic memory allocation)은 포인터에 원하는 만큼 메모리 공간을 할당 받아 사용후 해제하는 방식이다. 필요한 메모리 크기는 바이트 단위로 지정하며 양수만 사용한다
      </p>
      <ul><span id="ulh">malloc → 사용 → free </span>_stdlib.h 헤더파일
        <li><span id="accent">자료형* 포인터 = malloc(sizeof(자료형));</span></li>
        <li><span id="accent">free(포인터);</span> 메모리 해제는 선택이 아닌 필수</li>
      </ul>
      <ul><span id="ulh">메모리함수 </span>_string.h 헤더파일
        <li><span id="comment">memset(포인터, 값, 메모리크기);</span> memory set 메모리크기만큼 특정값으로 전부 설정</li>
        <li><span id="comment">memcpy(목적지포인터, 원본포인터, 메모리크기);</span> memory copy 메모리크기만큼 값을 복사</li>
      </ul>


      <h3>void*포인터</h3>
      <p>기본적으로 C 언어는 자료형이 다른 포인터끼리 메모리 주소를 저장하면 컴파일 경고(warning)가 발생합니다. 하지만 void 포인터는 자료형이 정해지지 않은 특성 때문에 어떤 자료형으로 된
        포인터든 모두 저장할 수 있습니다. 반대로 다양한 자료형으로 된 포인터에도 void 포인터를 저장할 수도 있습니다. 이런 특성 때문에 void 포인터는 범용 포인터라고 합니다.</p>
      <ul><span id="ulh">선언</span>
        <li><span id="accent">void*포인터;</span> → 모든 포인터자료형으로 변환가능</li>
      </ul>
      <ul><span id="ulh">역참조</span>
        <li><span id="comment">void포인터는 역참조가 불가하다</span></li>
      </ul>


      <h3>이중포인터</h3>
      <p>포인터를 선언할 때 *를 두 번 사용하면 포인터의 포인터(이중 포인터)를 선언하고, 삼중 사중 그 이상의 포인터를 만들 수 있다</p>
      <ul><span id="ulh">선언</span>
        <li><span id="accent">자료형** 포인터;</span></li>
      </ul>
      <ul><span id="ulh">역참조</span>
        <li><span id="accent">**포인터 = 값;</span></li>
      </ul>


      <h3>널 포인터(null pointer)</h3>
      <p>주소 00000000 으로 아무것도 가리키지 않는 상태를 뜻합니다. 따라서 역참조는 할 수 없습니다. 실무에서는 다음과 같이 포인터가 NULL인지 확인한 뒤 NULL이면 메모리를 할당하는 패턴을 주로
        사용합니다.</p>
      <ul>
        <li><span id="accent">int* 포인터 = NULL; </span></li>
      </ul>

      <h3>연산</h3>
      <p>메모리 주소에 정수값을 더하거나 빼면 포인터 자료형의 크기만큼 메모리 주소가 증가, 감소합니다. 즉, 포인터 연산을 하면 다른 메모리 주소에 접근할 수 있습니다. <span id="comment">* /
          연산자와 실수는 연산불가</span></p>
      <ul><span id="ulh">기본포인터 연산</span>
        <li><span id="accent">포인터 + 정수값</span> 포인터자료형크기*정수값 만큼 순방향이동</li>
        <li><span id="accent">포인터 - 정수값</span> 포인터자료형크기*정수값 만큼 역방향이동</li>
        <li>구조체포인터연산하면 멤버자료형크기총합*정수값으로 이동된다</li>
      </ul>
      <ul><span id="ulh">기본포인터 증감연산</span>
        <li>증감연산은 연산과 할당을 같이 하는 연산자이므로 포인터의 값 자체가 바뀐다. 동적메모리할당 후 포인터에 증감연산을 하였다면 해제할때 주의해야한다</li>
        <li><span id="accent">포인터++</span> 포인터자료형크기*1 증가된 주소할당</li>
        <li><span id="accent">포인터--</span> 포인터자료형크기*1 감소된 주소할당</li>
        <li><span id="accent">++포인터</span> 포인터자료형크기*1 증가된 주소할당</li>
        <li><span id="accent">--포인터</span> 포인터자료형크기*1 감소된 주소할당</li>
      </ul>

      <ul><span id="ulh">역참조 연산</span>
        <li>포인터연산을 괄호로 묶어주지 않으면 역참조 연산자가 먼저 실행되어 값을 가져온 뒤 연산하므로 주의</li>
        <li><span id="accent">*(포인터 + 정수값)</span></li>
        <li><span id="accent">*(++포인터)</span> 연산할당 뒤 역참조</li>
        <li><span id="accent">*(포인터++) 역참조 뒤 연산할당</span></li>
      </ul>

      <ul><span id="ulh">void포인터 연산</span>
        <li>void 포인터는 자료형의 크기가 정해져 있지 않기 때문에 포인터 연산을 할 수 없다. 다른 포인터로 변환한 뒤 연산해야한다</li>
        <li><span id="accent">(자료형* )void포인터 + 정수값</span></li>
        <li><span id="accent">++(자료형* )void포인터</span></li>
        <li><span id="accent">((자료형* )void포인터)++</span></li>
      </ul>


      <h2>배열 → 포인터</h2>
      <p>배열은 주솟값이기 때문에 포인터에 바로 넣을 수 있습니다. 배열과 포인터의 차이점은 크기이다. 배열은 요소의 전체 합 만큼의 크기를 가지고, 포인터는 그냥 선언된 자료형의 크기만 차지한다</p>
      <h3>1차원배열→포인터</h3>
      <ul><span id="ulh">선언</span>
        <li>int 배열[크기] = {첫번째요소값, 값, 값,,,};</li>
        <li><span id="accent">int* 포인터 = 배열; </span> 배열이 포인터이기 때문에 &없이 할당가능</li>
      </ul>
      <ul><span id="ulh">할당</span>
        <li><span id="accent">포인터 = 배열; </span></li>
      </ul>
      <ul><span id="ulh">역참조</span>
        <li><span id="accent">*포인터 = *배열 = 첫번째요소값</span> 배열을 포인터에 할당한 뒤 포인터를 역참조해보면 배열의 첫 번째 요소의 값이 나옵니다. 마찬가지로 배열 자체도
          역참조해보면 배열의 첫 번째 요소의 값이 나옵니다.</li>
      </ul>
      <ul><span id="ulh">접근</span>
        <li><span id="accent">포인터[인덱스] = 값</span> 배열을 담은 포인터는 역참조하지않아도 요소값이 나옴</li>
      </ul>
      <ul><span id="ulh">동적메모리할당</span>
        <li><span id="accent">자료형* 포인터 = malloc(sizeof(자료형) * 크기);</span></li>
        <li><span id="accent">free(포인터);</span></li>
        <li>int* numPtr = malloc(sizeof(int) * 10);</li>
      </ul>


      <h3>2차원배열→포인터</h3>
      <ul><span id="ulh">선언</span>
        <br><img src="C언어_배열2차원포인터.JPG" border="1">
        <li>int 2차원배열[세로크기][가로크기] = { { 세로첫번째값, 값, 값 }, {값, 값, 값} };</li>
        <li><span id="accent">int (*포인터)[가로크기] = 2차원배열; </span>가로크기를 가진 배열을 가리키는 포인터, 세로크기는 모름, 자료형과 가로 크기가 일치해야 합니다.</li>
      </ul>
      <ul><span id="ulh">할당</span>
        <li><span id="accent">포인터 = 2차원배열; </span></li>
      </ul>
      <ul><span id="ulh">역참조</span>
        <li><span id="accent">*포인터 = *2차원배열 = 세로 첫 번째의 주소</span> 2차원배열 및 포인터를 역참조하면 세로 첫 번째의 주소가 나옴
          <br><span id="question">의문 : 2차원배열의 역참조값은 요소값이 아니라 왜 요소의 '주소값'이지?
            <br>답 : 아마도 2차원배열포인터는 가로크기를 가진 '배열'을 가르키는 포인터이기 때문에, 배열이라는 주소를 가리키는 포인터는 역참조하더라도 주소를 가르키는 것 같아
        </li>
      </ul>
      <ul><span id="ulh">접근</span>
        <li><span id="accent">포인터[세로][가로] = 값</span> 배열을 담은 포인터는 역참조하지않아도 요소값이 나옴</li>
      </ul>
      <br>
      <ul><span id="ulh">동적메모리할당</span>
        <br><img src="C언어_포인터2차원배열.JPG" width="600" border="1">
        <li><span id="accent">자료형** 포인터 = malloc(sizeof(자료형*) * 세로크기);</span> 이중포인터로 세로 공간 메모리 할당</li>
        <li><span id="accent">for반복문 세로크기반복 {포인터[i] = malloc(sizeof(자료형) * 가로크기);}</span> 반복문으로 가로 공간 메모리 할당</li>
        <li><span id="accent">for반복문 {free(포인터[i]);}</span> 반복문으로 가로 공간 메모리 해제</li>
        <li><span id="accent">free(포인터);</span> 세로 공간 메모리 해제</li>
        <li><span id="comment">메모리할당시 세로→가로 순서, 메모리해제시 반대로 가로→세로 진행</span></li>
      </ul>


      <h2>포인터 → 배열</h2>
      <ul><span id="ulh"></span>
        <li><span id="accent">int* 포인터[크기]</span> 포인터를 요소로 n크기만큼 가진 배열</li>
        <li><span id="comment">비교주의하기 : int (*포인터)[크기]</span> n크기의 배열을 가리키는 포인터, 2차원배열포인터에서 등장하는 형태</li>
      </ul>

      <h1>문자열</h1>
      <h2>문자와 문자열</h2>
      <p>문자는 'a'처럼 글자가 하나만 있는 상태를 뜻하고 문자열은 "Hello"처럼 글자 여러 개가 계속 이어진 상태를 뜻합니다.
        <br>C언어에는 문자열자료형이 따로 없어 문자열은 " "(큰따옴표)로 묶어 char 포인터나 배열에 저장하여 사용합니다.
      </p>



      <h2>문자열 → 배열</h2>
      <p><img src="C언어_문자열배열.JPG" width="600" border="1">
      <h3>선언 및 접근</h3>
      <ul><span id="ulh">선언</span>
        <li><span id="accent">char 문자열배열[크기] = "문자열";</span> 배열에 문자열을 할당하려면 선언과 동시에 할당(초기화)해야만 한다. 단 scanf에는 선언해놓고 할당가능</li>
        <li><span id="accent">char 문자열배열[] = "문자열";</span> 크기생략시 (문자개수+NULL) 갯수로 자동지정된다</li>
      </ul>
      <ul><span id="ulh">접근</span>
        <li><span id="accent">문자열배열[인덱스]</span> 인덱스는 0부터 첫글자로 시작하고 마지막엔 NULL(=0\)값이 들어있다.</li>
        <li><span id="accent">문자열배열[인덱스]=값;</span> 재할당가능</li>
      </ul>
      <ul><span id="ulh">서식지정자</span>
        <li><span id="accent">printf("%c", 문자열배열[인덱스]);</span> 문자한개씩 출력</li>
      </ul>

      <h3>입력받기(scanf)</h3>
      <ul><span id="ulh">한줄</span>
        <li><span id="accent">scanf("%s", 문자열배열);</span> 문자열배열앞에 &를 붙이지 않는다</li>
        <li><span id="comment">scanf("%[^\n]s", 문자열배열);</span> %s는 공백을 입력받지 못하고, %[^\n]s는 공백까지 입력받는다</li>
        <li>사용자입력시 ""를 생략하고 바로 문자를 입력한다</li>
      </ul>
      <ul><span id="ulh">여러줄</span>
        <li><span id="comment">scanf("%s %s ...", 문자열배열1, 문자열배열2, ...);</span>공백으로 구분되는 여러줄</li>
        <li><span id="comment">scanf("%s\n%s ...", 문자열배열1, 문자열배열2, ...);</span>줄띄우기로 구분되는 여러줄</li>
      </ul>



      <h2>문자열 → 포인터 (읽기전용)</h2>
      <p><img src="C언어_문자열포인터.JPG" width="600" border="1">
        <br>포인터문자열은 변수 s1안에 저장되지 않고 문자열이 있는 곳의 메모리 주소만 저장됩니다. 저장위치는 컴파일러가 알아서 결정하고 읽기전용이기때문에 초기할당 후 수정이불가합니다.
      </p>
      <h3>선언 및 접근</h3>
      <ul><span id="ulh">선언</span>
        <li><span id="accent">char* 문자열포인터 = "문자열";</span>
          <br><span id="question">의문 : 포인터자료형에는 주소만 할당가능한데 어떻게 문자열이 바로오지??
            <br>답 : 문자열도 일종의 배열같은 건가봄 {}와""의 차이일뿐??</span>
        </li>
      </ul>
      <ul><span id="ulh">접근</span>
        <li><span id="accent">문자열포인터[인덱스]</span> 인덱스는 0부터 첫글자로 시작하고 마지막엔 NULL값이 들어있다.</li>
        <li><span id="accent">문자열포인터[인덱스]=값; (X)</span> 읽기 전용이므로 재할당이 불가</li>
      </ul>
      <ul><span id="ulh">서식지정자</span>
        <li><span id="accent">printf("%s", 문자열포인터);</span> 문자열출력
          <br><span id="question">의문 : 포인터는 주소인데 어떻게 값인 문자열이 출력됐지??
            <br>답 : 문자열도 일종의 배열같은거랬으니까 문자열은 값으로 보이는 주소 아닐까??</span>
        </li>
        <li>printf("%p", 문자열포인터); 문자열이 저장된 주소출력</li>
        <li>printf("%c", *문자열포인터); 첫번째문자 출력 <span id="comment">배열을 역참조하면 첫번째요소가 출력되는 것과 비슷</span></li>
      </ul>


      <h3>입력받기(scanf)</h3>
      <ul><span id="ulh">한줄</span>
        <li>문자열포인터의 값은 읽기전용이므로 동적메모리할당 후 입력을 받아야한다</li>
        <li><span id="accent">char* 문자열포인터 = malloc(sizeof(char) * 크기); </span></li>
        <li><span id="accent">scanf("%s", 문자열포인터);</span> 문자열포인터앞에 &를 붙이지 않는다</li>
        <li><span id="accent">free(문자열포인터);</span></li>
      </ul>
      <ul><span id="ulh">여러줄</span>
        <li>동적메모리할당 후</li>
        <li><span id="comment">scanf("%s %s ...", 문자열포인터1, 문자열포인터2, ...);</span>공백으로 구분되는 여러줄</li>
        <li><span id="comment">scanf("%s\n%s ...", 문자열포인터1, 문자열포인터2 ...);</span>줄띄우기로 구분되는 여러줄</li>
      </ul>

      <h2>문자열 연관함수</h2>
      <ul><span id="ulh">길이 strlen(string length)</span>
        <li><span id="accent">strlen(배열/포인터);</span>_헤더파일string.h</li>
        <li>NULL부분은 포함하지 않고 길이를 구한다</li>
      </ul>

      <ul><span id="ulh">크기비교 strcmp(string compare)</span>
        <li><span id="accent">strcmp(문자열A, 문자열B);</span>_헤더파일string.h</li>
        <li>각 문자의 ASCII 코드를 비교하여 같으면0, 문자열A가 크면 1, 문자열B가 크면 -1 </li>
        <li>대소문자를 구분하며, 배열 포인터 저장방식은 구분하지 않음 </li>
      </ul>

      <ul><span id="ulh">복사 strcpy(string copy)</span>
        <li><span id="accent">strcpy(대상문자열, 원본문자열);</span>_헤더파일string.h</li>
        <li><span id="comment">원본값이 수정되는 작업이므로 읽기전용인 포인터는 동적메모리할당해야한다</span></li>
      </ul>

      <ul><span id="ulh">연결 strcat(string concatenate)</span>
        <li><span id="accent">strcat(최종문자열, 붙일문자열);</span>_헤더파일string.h</li>
        <li><span id="comment">원본값이 수정되는 작업이므로 읽기전용인 포인터는 동적메모리할당해야한다</span></li>
      </ul>


      <ul><span id="ulh">문자검색 strchr(string character)</span>
        <li><span id="accent">strchr(대상문자열, 검색할문자);</span>_헤더파일string.h</li>
        <li>대소문자구분하며, 문자를 찾았으면 문자로 시작하는 문자열포인터 반환, 문자가 없으면 NULL 반환</li>
        <li>strrchr 는 문자열의 오른쪽부터 문자검색</li>
      </ul>

      <ul><span id="ulh">문자열검색 strstr(string (find) string)</span>
        <li><span id="accent">char* 포인터 = strstr(대상문자열, 검색할문자열);</span>_헤더파일string.h</li>
        <li>대소문자구분하며, 문자열을 찾았으면 문자열로 시작하는 문자열포인터 반환, 문자열이 없으면 NULL을 반환</li>
      </ul>

      <ul><span id="ulh">문자열나누기 strtok(string tokenize)</span>
        <li><span id="accent">char* 포인터 = strtok(대상문자열, "기준문자여러개");</span>_헤더파일string.h</li>
        <li>문자열에서 기준문자들을 찾은 후 NULL로 반환하여 문자열을 나눈다</li>
        <li><span id="comment">원본값이 수정되는 작업이므로 읽기전용인 포인터는 동적메모리할당해야한다</span></li>
      </ul>

      <ul><span id="ulh">문자열생성 sprintf</span>
        <li><span id="accent">sprintf(배열/포인터, 서식, 값);</span>_헤더파일stdio.h</li>
        <li>버퍼(buffer) 배열에 다양한 서식값을 문자열로 변환하여 넣는 함수</li>
        <li><span id="comment">원본값이 수정되는 작업이므로 읽기전용인 포인터는 동적메모리할당해야한다</span></li>
      </ul>

      <ul><span id="ulh">정수를 문자열로 atoi, strtol</span>
        <li><span id="accent">atoi(문자열);</span>_헤더파일stdlib.h</li>
        <li><span id="comment">num1 = strtol(문자열, 끝포인터, 진법);</span>_헤더파일stdlib.h</li>
        <li>정수형태 문자열만 정수로 변환가능, 이외 0으로 반환, 10진법 16진법 8진법가능</li>
      </ul>

      <ul><span id="ulh">실수를 문자열로 atof, strtof</span>
        <li><span id="accent">atof(문자열);</span>_헤더파일stdlib.h</li>
        <li><span id="comment">num1 = strtof(문자열, 끝포인터);</span>_헤더파일stdlib.h</li>
        <li>실수형태 문자열만 실수로 변환가능, 이외 0으로 반환</li>
        <li>반대로 숫자를 문자열로 변환하고자 할때는 sprintf함수 사용</li>
      </ul>


      <h1>구조체(struct), 공용체(union), 열거형(enum)</h1>
      <h2>구조체</h2>
      <p>구조체는 struct 키워드로 정의하며, 관련 정보를 하나의 의미로 묶을 때 사용합니다.구조체는 보통 main 함수 바깥에 정의합니다. 만약 함수 안에서 구조체를 정의하면 해당 함수 안에서만 구조체를
        사용할 수 있습니다.</p>
      <ul><span id="ulh">정의</span>
        <li><span id="accent">struct 구조체태그 { 자료형 멤버들,,, };</span></li>
      </ul>

      <ul><span id="ulh">별칭</span>
        <li><span id="accent">typedef</span> struct 구조체태그 { 자료형 멤버들,,, } <span id="accent">구조체별칭;</span></li>
        <li><span id="accent">typedef</span> struct { 자료형 멤버들,,, } <span id="accent">구조체별칭;</span> 익명구조체(anonymous structure)
        </li>
        <li><span id="comment">'struct 구조체태그 = 구조체별칭' 으로 이해하면 된다.</span></li>
      </ul>

      <ul><span id="ulh">변수할당</span>
        <li>구조체를 정의한뒤 변수를 선언해야 값을 할당 할 수 있다</li>
        <li><span id="accent">struct 구조체태그 구조체변수 ;</span> 선언 후 개별 접근으로 값을 할당하거나 </li>
        <li><span id="comment">구조체별칭 구조체변수 ;</span></li>
        <li><span id="accent">struct 구조체태그 구조체변수 = {값,,,};</span> 변수선언 동시에 배열형태로 값을 할당 할 수 있다 </li>
        <li><span id="comment">struct 구조체태그 구조체변수 = { .멤버1 = 값1, .멤버2 = 값2 };</span> </li>
        <li><span id="comment">struct 구조체태그 구조체변수 = { 0, };</span> 0으로 초기화</li>
      </ul>

      <ul><span id="ulh">접근</span>
        <li><span id="accent">구조체변수.멤버 = 값;</span></li>
      </ul>

      <h3>구조체 속의 구조체</h3>
      <ul><span id="ulh">선언</span>
        <li>구조체 안에<span id="accent"> struct 구조체태그 구조체변수 ;</span> 멤버로 선언</li>
      </ul>
      <ul><span id="ulh">변수할당</span>
        <li><span id="comment">struct 구조체태그 구조체변수 = { 값1, 값2, { 값3, 값4 } };</span></li>
      </ul>
      <ul><span id="ulh">접근</span>
        <li><span id="accent">구조체변수.멤버.멤버 = 값;</span></li>
      </ul>


      <h2>구조체 → 배열</h2>
      <p><img src="C언어_구조체배열.JPG" width="600" border="1"></p>
      <ul><span id="ulh">선언</span>
        <li><span id="accent">struct 구조체태그 구조체배열[크기];</span> </li>
        <li><span id="comment">struct 구조체태그 구조체배열[크기] = { { 값1, 값2 }, { 값3, 값4 } };</span> </li>
        <li><span id="comment">struct 구조체태그 구조체배열[크기] = { { .멤버이름1 = 값1, .멤버이름2 = 값2 },{ .멤버이름1 = 값3, .멤버2 = 값4 } };</span>
        </li>
        <li><span id="comment">struct 구조체태그 구조체배열[크기] = { 0, };</span> 0으로 초기화</li>

      </ul>
      <ul><span id="ulh">접근</span>
        <li><span id="accent">구조체배열[인덱스].멤버 = 값;</span> </li>
      </ul>


      <h2>구조체 → 포인터</h2>
      <h3>동적메모리할당 선언</h3>
      <p>보통 구조체는 멤버 변수가 여러 개 들어있어서 크기가 큰 편입니다. 그래서 구조체 변수를 일일이 선언해서 사용하는 것보다는 포인터에 메모리를 할당해서 사용하는 편이 효율적입니다. main함수 밖에서
        함수를 만들어서 구조체를 사용할 때 포인터를 자주 활용하게 됩니다.</p>
      <ul><span id="ulh"></span>
        <li><span id="accent">struct 구조체태그* 구조체포인터 = malloc(sizeof(struct 구조체태그));</span></li>
        <li><span id="comment">구조체별칭* 구조체포인터 = malloc(sizeof(구조체별칭));</span></li>
        <li><span id="accent">free(구조체포인터);</span></li>
      </ul>

      <h3>기본선언 및 할당</h3>
      <ul><span id="ulh">선언</span>
        <li><span id="accent">struct 구조체태그* 구조체포인터 </span></li>
        <li><span id="accent">struct 구조체태그* 구조체포인터 = &구조체변수;</span> 선언과 할당 동시</li>
      </ul>
      <ul><span id="ulh">포인터별칭</span>
        <li>typedef struct 구조체태그 { 자료형 멤버들,,, } 구조체별칭, <span id="accent">*구조체포인터별칭;</span></li>
        <li>구조체 포인터 별칭을 사용하면 *를 사용하지 않고 포인터를 선언할 수 있습니다.</li>
      </ul>
      <ul><span id="ulh">할당</span>
        <li><span id="accent">구조체포인터 = &구조체변수; </span></li>
      </ul>

      <h3>접근 및 역참조</h3>
      <ul><span id="ulh">접근</span>
        <li><span id="accent">구조체포인터->멤버 = 값;</span> 화살표 연산자(arrow operator)</li>
        <li><span id="comment">구조체변수.멤버 = 값;</span></li>
      </ul>
      <ul><span id="ulh">역참조</span>
        <li><span id="accent">(*구조체포인터).멤버 = 값</span> 괄호를 붙이지 않으면 멤버를 역참조한다는 의미이다</li>
      </ul>
      <h3>메모리함수</h3>
      <ul><span id="ulh"></span>
        <li><span id="comment">memset(구조체포인터/&변수, 값, 크기);</span> 설정한메모리크기만큼 모든값을 한번에 설정할 수 있다</li>
        <li><span id="comment">memcpy(목적지포인터/&변수, 원본포인터/&변수, 크기);</span> 원본값을 다른곳으로 복사할 수 있다. 포인터와 &변수가 혼재되어도 상관없다</li>
      </ul>



      <h2>구조체 → 포인터 → 배열</h2>
      <p><img src="C언어_구조체포인터배열.JPG" width="600" border="1"></p>
      <ul><span id="ulh">선언</span>
        <li><span id="accent">struct 구조체태그* 구조체포인터[크기];</span> </li>
      </ul>
      <ul><span id="ulh">동적메모리할당</span>
        <li><span id="comment">for문으로 요소개수만큼 반복하면서 각 요소에 구조체 크기만큼 메모리 할당</span> </li>
        <li><span id="comment">for문으로 요소개수만큼 반복하면서 메모리 해제</span> </li>
      </ul>

      <ul><span id="ulh">접근</span>
        <li><span id="accent">구조체포인터[인덱스]->멤버 = 값;</span> </li>
      </ul>



      <h2>구조체 멤버 정렬</h2>
      <h3>바이트크기 조절</h3>
      <p>C 언어는 CPU에서 메모리에 접근하는 효율을 높이기 위해 구조체를 일정한 크기로 정렬을 합니다. 이때 멤버 중에서 큰 자료형 크기의 배수로 정렬하며 남는 공간을 채우는 것을 패딩이라 부릅니다.
        컴파일러에서 제공하는 지시자를 사용하면 정렬 크기를 수기 조종 가능하다. 구조체를 1바이트 크기로 정렬하는 것은 구조체의 내용을 파일에 쓰거나 네트워크로 전송할 때 쓰인다.</p>
      <ul><span id="ulh">상대위치</span>
        <li><span id="comment">offsetof(struct 구조체, 멤버) </span>_stddef.h 헤더파일</li>
      </ul>
      <ul><span id="ulh">정렬크기조절</span>
        <li><span id="comment">#pragma pack(push, 정렬크기) </span>크기는 1,2,4,8,16으로 증가</li>
        <li><span id="comment">#pragma pack(pop) </span></li>
      </ul>
      <h3>비트크기 조절</h3>
      <p>구조체의 멤버는 각 자료형 크기만큼 공간을 차지했습니다. 하지만 구조체 비트 필드를 사용하면 구조체 멤버를 비트 단위로 저장할 수 있습니다.(정수 자료형만 사용가능) CPU나 기타 칩의 플래그를
        다루는 저수준(low level) 프로그래밍을 할 때 기본 자료형보다 더 작은 비트 단위로 값을 가져오거나 저장하는 경우가 많으므로 구조체 비트 필드가 유용하게 사용됩니다.</p>
      <ul><span id="ulh">정의</span>
        <li><span id="comment">struct 구조체태그 { 자료형 멤버 : 비트수; ,,, } </span></li>
        <li><span id="comment">공용체도 가능 </span></li>
      </ul>



      <h2>공용체</h2>
      <p>구조체는 멤버들이 각각 공간을 차지하지만 공용체는 멤버중 가장 큰 자료형 공간을 모든 멤버가 공유합니다. 공용체는 여러 멤버에 동시에 접근하지 않는 경우 같은 메모리 레이아웃에 멤버를 모아둘 때
        사용합니다. 특히 공용체는 임베디드 시스템이나 커널 모드 디바이스 드라이버 등에서 주로 사용하며 보통은 거의 쓰지 않습니다.
        <br><img src="C언어_구조체공용체.JPG" width="600" border="1">
      </p>
      <ul><span id="ulh">정의</span>
        <li><span id="accent">union 공용체태그 { 자료형 멤버들,,, };</span></li>
        <li><span id="comment">이후 대부분의 문법은 구조체와 동일</span></li>
      </ul>


      <h2>열거형</h2>
      <p>열거형은 공통된 상수멤버들을 모아 상수인 정수값을 부여한다. 열거형 첫멤버에 초기값을 지정하면 자동으로 1씩 증가하고, 초깃값을 지정하지 않으면 0부터 시작한다. 모든 멤버에 정수상수값을 각각 부여할
        수도 있다.</p>
      <ul><span id="ulh">정의</span>
        <li><span id="accent">enum 열거형태그 { 상수멤버1 = 초깃값정수, 상수멤버2,,,, } 열거형별칭;</span></li>
      </ul>
      <ul><span id="ulh">변수선언</span>
        <li><span id="accent">enum 열거형태그 변수;</span></li>
        <li><span id="accent">변수 = 상수멤버 / 매칭정수값;</span></li>
      </ul>
      <ul><span id="ulh">for 반복문</span>
        <li><span id="comment">for(열거형별칭 i = 상수멤버1; i < 상수멤버마지막; ㅑ++)</span>
        </li>
      </ul>


      <h1>자료형의 변환</h1>
      <h2>형 확장(type promotion), 암시적 형 변환(implicit type conversion)</h2>
      <p>자료형의 크기가 큰 쪽, 표현 범위가 넓은 쪽으로 변환되는 것은 값손실이 없기때문에 컴파일러가 자동으로 변환한다. 예를들어 서로 다른 자료형으로 연산을 했을 때, 크기가 큰 자료형에 작은 자료형을
        할당했을때 큰 자료형으로 암시적 형 변환이 일어납니다.
        <br><span id="comment">정수와 실수를 함께 연산하면 결괏값은 실수로 자동변환된다. 왜냐하면 실수가 정수보다 표현 범위가 넓기 때문이다.</span>
      </p>

      <h2>형 축소(type demotion), 명시적 형 변환(explicit type conversion)</h2>
      <p>자료형 크기가 작은 쪽, 표현 범위가 좁은 쪽으로 변환되는 것은 값손실이 일어나기 때문에 컴파일 경고가 발생한다. 따라서 형 축소는 프로그래머가 의도적으로 변환해야 가능하다.
        <br><span id="comment">기본자료형을 명시적 형 변환 할때 변수나 값 앞에 변환할 자료형을 붙인 뒤 (괄호)로 묶어주면 됩니다.</span>
      </p>
      <ul><span id="ulh"></span>
        <li><span id="accent">(자료형)변수</span></li>
        <li><span id="comment">(자료형)함수</span> 함수도 자료형 변환이 가능하다</li>
      </ul>


      <h2>포인터 자료형 변환</h2>
      <p>포인터를 형 축소 하게 되면 변수가 할당된 메모리 공간은 그대로이고, 주소를 가져오는 포인터의 크기만 달라져 일부주소만 가져온다. 반대로 포인터가 형 확장하면 옆의 메모리 공간을 침범하여 주소를
        가져오게 됩니다.</p>

      <ul><span id="ulh">기본포인터</span>
        <li><span id="accent">(자료형* )포인터</span> 변환</li>
        <li><span id="accent">*(자료형* )포인터</span> 변환하며 역참조 </li>
      </ul>

      <ul><span id="ulh">void포인터</span>
        <li><span id="accent">(자료형* )void포인터</span></li>
        <li><span id="accent">*(자료형* )void포인터</span> 원래 역참조가 불가한 void 포인터는 자료형변환을 통해 역참조가 가능하다</li>
      </ul>

      <ul><span id="ulh">구조체포인터</span>
        <li><span id="accent">(struct 구조체* )포인터</span> 변환</li>
        <li><span id="accent">(구조체별칭* )포인터</span> 변환</li>
        <li><span id="accent">(구조체포인터별칭)포인터</span> 변환</li>
        <li><span id="accent">((struct 구조체* )포인터)->멤버</span> 접근, 전체괄호로 묶어줘야함</li>
      </ul>


      <h1>함수(function)</h1>
      <p>특정 용도의 코드들을 한 곳에 모아놓은 것을 뜻한다. printf, scanf 등도 모두 C 언어에서 미리 만들어둔 함수이다.</p>
      <h2>정의와 선언</h2>
      <p>기본적으로 main함수 바깥 위에 함수를 정의하여야한다. 그렇지 않을경우 함수선언을 추가적으로 하여 해당함수가 어딘가 있다고 알려줘야한다.</p>
      <ul><span id="ulh">정의</span>
        <li><span id="accent">반환값자료형 함수( ){ 코드; }</span> </li>
      </ul>

      <ul><span id="ulh">선언</span>
        <li><span id="accent">반환값자료형 함수( );</span></li>
        <li>선언과 정의가 분리된 상태에서는 함수선언 부분을 함수원형(function prototype), 함수정의 부분을 함수헤더(function header)와 함수본체(function body)라고
          부른다.
          <br><img src="C언어_함수.JPG" border="1">
        </li>
      </ul>

      <ul><span id="ulh">호출</span>
        <li><span id="accent">함수( );</span></li>
      </ul>

      <h2>함수구조 INPUT 과 OUTPUT</h2>
      <p><img src="C언어_함수구조.JPG" border="1" width="600px">
        <br>함수는 독립된 공간이므로 함수 안에서 선언된 변수는 다른 함수에서 사용할 수 없습니다. 함수 안에 선언된 변수의 값을 다른 함수에서 사용하고 싶다면 반환값과 매개변수를 이용해야 합니다.
      </p>


      <h2>INPUT_ parameter와 argument</h2>
      <p>parameter (매개변수,형식매개변수,인자) : 함수를 정의할때 함수 바깐에서 전달된 값을 담아 함수 내부에서 사용할 수 있게 정의된 변수
        <br>argument (인수,실행전달인자,전달인자) : 함수가 호출될 때 함수로 값을 전달해주는 변수
      </p>
      <ul><span id="ulh">정의</span>
        <li><span id="accent">반환값자료형 함수(자료형 매개변수,,){ 코드;}</span> 여러개의 매개변수를 선언할때마다 자료형을 붙여줘야함 int a,b,c(X)</li>
        <li><span id="comment">int add(int a, int b){return a+d;}</span> 매개변수와 반환값을 함께 사용</li>
      </ul>
      <ul><span id="ulh">호출</span>
        <li><span id="accent">함수(값);</span></li>
      </ul>
      <ul><span id="ulh">매개변수가 없을때</span>
        <li><span id="comment">반환값자료형 함수( ){ 코드;}</span> 매개변수 목록이 정의되지 않았다는 의미</li>
        <li><span id="comment">반환값자료형 함수(void){ 코드;}</span> 매개변수가 없다는 의미</li>
      </ul>

      <h3>문자열 매개변수</h3>
      <p>매개변수로 문자열을 받으려면 매개변수를 문자열포인터로 지정하거나 배열로 지정한다.</p>
      <ul><span id="ulh">정의</span>
        <li><span id="accent">반환값자료형 함수(char *매개변수,,){ 코드;}</span></li>
        <li><span id="accent">반환값자료형 함수(char 매개변수[],,){ 코드;}</span></li>
      </ul>
      <ul><span id="ulh">호출</span>
        <li><span id="accent">함수("문자열");</span></li>
        <li><span id="accent">함수(미리정의된문자열배열이름);</span></li>
      </ul>


      <h3>포인터 매개변수 (INPUT된 값에 직접접근)</h3>
      <p><span id="comment">일반인수는 함수안으로 값을 복사하여 전달하고 함수안에서 쓰여진 변수는 함수안에서만 유효하므로 바깥으로 값을 내보낼 수 없다. 포인터 매개변수를 사용하면 주소값인수가 함수 안에
          메모리주소를 전달하고 함수 안에서는 전달된 변수의 메모리주소에 접근하여 값을 저장할 수 있다.
          <br>또한 input인 매개변수는 여러개를 정의할 수 있지만, output인 return값은 하나만 정의 할 수 있다. 여러개를 반환하고 싶을 때 주로 사용하는 방법은 포인터 매개변수이다.같은
          원리로 함수 바깥으로 여러개의 값을 전달 하는 scanf함수는 인수로 &주소값을 사용한다</span></p>
      <ul><span id="ulh">정의</span>
        <li><span id="accent">반환값자료형 함수(자료형 *매개변수,,){ 코드;}</span></li>
      </ul>
      <ul><span id="ulh">호출</span>
        <li><span id="accent">함수(&변수);</span></li>
      </ul>
      <ul><span id="ulh">void 포인터 매개변수 </span>
        <li>void 포인터 매개변수에는 변수의 메모리 주소뿐만 아니라 메모리를 할당한 포인터도 넣을 수 있습니다. 또한, 일반 자료형의 포인터뿐만 아니라 구조체, 공용체, 열거형 등의 포인터도 넣을 수
          있습니다.</li>
      </ul>

      <h3>배열 매개변수</h3>
      <p>배열도 포인터와 같으므로 함수 안에서 매개변수로 받은 배열의 요소를 변경하면 함수 바깥에 있는 배열의 요소가 바뀌게 됩니다.</p>
      <ul><span id="ulh">정의</span>
        <li><span id="accent">반환값자료형 함수(자료형 매개변수[],,){ 코드;}</span></li>
        <li><span id="accent">반환값자료형 함수(자료형 *매개변수,,){ 코드;}</span> 포인터로 배열을 받을수도있다</li>
      </ul>
      <ul><span id="ulh">호출</span>
        <li><span id="accent">함수(미리정의된배열이름);</span></li>
      </ul>


      <h3>이중포인터 매개변수</h3>
      <p>함수안의 지역변수는 다른 함수로 입출입이 불가하기 때문에 포인터 매개변수를 이용하여 일반변수의 주소값을 가져와사용하였다. 그렇다면 포인터의 주소값을 얻어오려면 어떻게 해야 할까? 이중포인터 매개변수를
        사용한다</p>


      <h3>구조체 매개변수</h3>
      <p>매개변수로 구조체를 정의할 수있으며, 구조체포인터도 정의가능하다</p>
      <ul><span id="ulh">정의</span>
        <li><span id="accent">반환값자료형 함수(struct 구조체이름 매개변수,,){ 코드;}</span></li>
        <li><span id="accent">반환값자료형 함수(struct 구조체이름 *매개변수,,){ 코드;}</span></li>
      </ul>
      <ul><span id="ulh">호출</span>
        <li><span id="accent">함수(미리할당된구조체변수);</span></li>
        <li><span id="accent">함수(&미리할당된구조체변수);</span></li>
      </ul>

      <h3>가변인자 매개변수</h3>
      <p>C 언어에서 함수를 사용하다 보면 printf, scanf같이 매개변수의 개수가 정해지지 않은 함수가 있습니다. 이렇게 매번 함수에 들어가는 인수(argument)의 개수가 변하는 것을 가변
        인자(가변 인수, variable argument)라고 합니다.</p>


      <h2>OUTPUT_ 반환값 return ;</h2>
      <p>반환값은 함수를 호출해준 바깥에 결괏값을 알려주기 위해 사용한다. 중요한 점은 반환값과 반환값자료형이 일치해야 하며, 반환값은 하나여야 한다.
        <br><span id="comment">return은 c언어에서 미리 정해놓은 예약어로서 '현재함수에서 빠져나가 그 함수를 호출했던 곳으로 되돌아 가라'는 뜻이다. return은 함수의 어디에도 위치할 수
          있으며 return이 실행되는 즉시 그 함수 또한 실행 종료된다. main함수에서 return 0;을 반환하는 이유는 성공했을때 0 실패했을때 1을 반환하는 것이 보통이기 때문이다. </span>
        <br><span id="question">의문 : return뒤에 함수가 오지는 못하나? <br>답 : 가능함 재귀함수는 반환값으로 자기자신 넣잖아. 함수포인터를 이용해서 함수자체를 반환하는것도 가능하고 근데
          반환값과 반환값자료형이 항상 일치해야하는거 조심</span>
      </p>
      <ul><span id="ulh">정의</span>
        <li><span id="accent">반환값자료형 함수( ){ 코드; return 반환값;}</span> </li>
      </ul>
      <ul><span id="ulh">호출</span>
        <li><span id="accent">함수( );</span></li>
        <li><span id="comment">변수 = 함수( );</span> 함수의 반환값을 변수에 저장한뒤 사용</li>
      </ul>
      <ul><span id="ulh">반환값이 없을때</span>
        <li><span id="comment">void 함수( ){ 코드;}</span> 반환값자료형에 void를 적어주면 함수의 반환값이 없다는 의미</li>
      </ul>


      <h3>포인터 반환값</h3>
      <p>포인터를 반환하려면 반환값자료형과 함수이름 사이에 * 를 붙인다.
        <br>함수안에서 변수를 선언(지역변수)하고 반환하면 함수가 끝나면 해당 변수는 사라지고 메모리에는 다른 값이 덧씌워질 수 있다. 따라서 함수를 벗어나도 메모리가 유지되는 malloc함수를 통해
        메모리를 할당한 뒤 함수를 호출해서 사용하고 그 뒤에 free함수로 메모리 해제를 해주어야한다.
      </p>
      <ul><span id="ulh">정의</span>
        <li><span id="accent">반환값자료형* 함수( ); {포인터변수 = malloc; return 포인터변수;}</span></li>
      </ul>
      <ul><span id="ulh">할당 및 호출</span>
        <li><span id="accent">반환값자료형* 새포인터변수;</span> </li>
        <li><span id="accent">새포인터변수 = 함수( );</span> </li>
        <li><span id="comment">void* 함수( ); {return malloc(바이트크기);}</span> 함수를 호출하면서 바로 반환할 수 있다</li>
      </ul>
      <ul><span id="ulh">메모리해제</span>
        <li><span id="accent">free(새포인터변수);</span> </li>
      </ul>

      <p><span id="question">의문 : free함수로 해제할때 최초선언된 변수를 넣는게 아니라, free함수를 사용하는 함수 안에서 변환된 변수 기준으로 넣어야하나?
          <br>답 : ㅇㅇ 그리고 심지어 동적메모리할당함수를 다른 함수에서 반환해서 사용할때마다 그 함수 안에서 해제해줘야함
          <br>추가의문 : 그럼 함수안에서 동적메모리할당 코드를 작성했을때 다른곳에서 반환되서 쓰이지 않으면 해제할 필요도 없는 건가? 함수가 불러와져서 사용될때만 해제해야하는거야?
          <br>답 : ★★ </p>
      <p><span id="question">의문 : 왜 문자열은 다른 함수에서 선언한뒤 반환하더라도 메모리에서 사라지지 않지?
          <br>답 : 컴퓨터에서는 지역 변수를 선언하고, 함수를 호출할 때 스택을 사용하기 때문입니다. 스택은 접시 쌓기에 비유할 수 있는데요. 접시를 순서대로 아래에서 위로 쌓고, 위에서부터 꺼내 쓸
          수는 있지만 중간부터 빼서 쓸 수는 없는 규칙이 있습니다.함수를 호출하면 접시를 하나 쌓습니다. 그리고 함수 안에서 변수를 선언할 때마다 접시를 계속 쌓게 됩니다. 만약 함수가 끝나면 함수 부분에
          해당하는 접시만 중간에서 뺄 수 없기 때문에 위에 있는 변수부터 차례대로 꺼낸 뒤 함수를 꺼냅니다. 이런 규칙 때문에 함수 안에 선언된 변수는 함수가 끝나면 사라지게 됩니다.정적 변수는 스택을
          사용하지 않으며 메모리에서 계속 유지되기 때문에 함수가 끝나도 사라지지 않습니다. 따라서 함수에서 정적 변수는 & (주소 연산자)로 메모리 주소를 반환해도 됩니다.</span>
        <br><img src="C언어_메모리구조.JPG" border="1">
        <br><img src="C언어_메모리구조2.JPG" border="1" width="626px">
      </p>


      <h3>구조체 반환값</h2>
        <p>C 언어의 함수는 반환값을 하나만 사용할 수 있다. 여러개의 데이터를 반환하려면 구조체 함수를 사용한다. 일반적으로 구조체변수를 정의하면 하나씩 멤버를 매칭하며 할당하는데, 함수안에 구조체변수와
          멤버매칭값을 넣으면 한번에 반환할 수 있다</p>
        <ul><span id="ulh">정의</span>
          <li><span id="accent">strunct 미리정의된구조체태그 함수( ); {strunct 미리정의된구조체태그 구조체변수; 멤버값할당; return 구조체변수;}</span> 이 방식으로 나중에
            함수값를 반환하면 해당 변수에 구조체변수의 내용이 모두 복사되므로 이중으로 메모리가 사용된다. 따라체 값이 저장된 메모리를 가르키는 포인터를 사용해야 메모리 사용에서 효율적이다</li>
        </ul>

        <ul><span id="ulh">할당 및 호출</span>
          <li><span id="accent">strunct 미리정의된구조체태그 새로운변수;</span></li>
          <li><span id="accent">새로운변수 = 함수();</span></li>
        </ul>

        <ul><span id="ulh">접근</span>
          <li><span id="accent">새로운변수.멤버이름</span></li>
        </ul>


        <h3>구조체 포인터 반환값</h3>
        <ul><span id="ulh">정의</span>
          <li><span id="accent">strunct 미리정의된구조체태그* 함수( ); {구조체포인터=malloc; 멤버값->할당; return 구조체포인터;}</span> </li>
        </ul>
        <ul><span id="ulh">할당 및 호출</span>
          <li><span id="accent">strunct 미리정의된구조체태그* 포인터변수;</span></li>
          <li><span id="accent">포인터변수 = 함수();</span></li>
        </ul>
        <ul><span id="ulh">접근</span>
          <li><span id="accent">포인터변수->멤버이름</span></li>
        </ul>
        <ul><span id="ulh">메모리해제</span>
          <li><span id="accent">free(포인터변수);</span></li>
        </ul>

        <h2>재귀함수</h2>
        <p>함수 안에서 함수 자기자신을 호출하는 방식을 재귀호출(recursive call)이라고 합니다. 재귀호출을 사용하려면 반드시 종료 조건을 만들어주어야 합니다.
          <br><img src="C언어_재귀함수.JPG" border="1" width="600px">
        </p>

        <h2>함수 포인터</h2>
        <p>함수를 가르키는 포인터.(함수이름도 사실은 포인터) <br>함수를 배열 또는 구조체에 넣거나, 함수 자체를 함수의 매개변수로 넘겨주고, 반환값으로 가져올때 함수포인터를 사용할 수 있다
          <br><img src="C언어_함수포인터.JPG" border="1" width="600px">
        </p>
        <ul><span id="ulh">정의</span>
          <li><span id="accent">반환값자료형 (*함수포인터)(매개변수자료형,,);</span> 매개변수의 자료형만 지정하고 이름은 생략가능</li>
        </ul>
        <ul><span id="ulh">할당</span>
          <li><span id="accent">함수포인터 = 미리정의된함수이름;</span> 함수뒤에 괄호없이 할당할것</li>
        </ul>
        <ul><span id="ulh">호출</span>
          <li><span id="accent">함수포인터(인수,,);</span></li>
        </ul>

        <h3>함수 포인터 배열</h3>
        <p>함수 포인터를 배열로 만들어 다양한함수를 하나의 포인터에 담아 인덱스로 호출 할 수 있다</p>
        <ul><span id="ulh">정의</span>
          <li><span id="accent">반환값자료형 (*함수포인터[크기])(매개변수자료형,,);</span></li>
        </ul>
        <ul><span id="ulh">할당</span>
          <li><span id="accent">함수포인터[index] = 미리정의된함수이름;</span></li>
          <li><span id="comment">int (*fp[4])(int, int) = { add, sub, mul, div };</span> 함수포인터 배열을 선언과 동시에 할당</li>
        </ul>
        <ul><span id="ulh">호출</span>
          <li><span id="accent">함수포인터[index](인수,,);</span></li>
        </ul>

        <h3>함수 포인터를 구조체멤버로</h3>
        <p>함수 포인터를 구조체 멤버로 정의하기</p>
        <ul><span id="ulh">정의</span>
          <li><span id="accent">struct 구조체 {반환값자료형 (*함수포인터[크기])(매개변수자료형,,);};</span></li>
        </ul>
        <ul><span id="ulh">할당</span>
          <li><span id="accent">struct 구조체 구조체변수;</span></li>
          <li><span id="accent">구조체변수.함수포인터 = 미리정의된함수이름;</span> </li>
        </ul>
        <ul><span id="ulh">호출</span>
          <li><span id="accent">구조체변수.함수포인터(인수,,);</span></li>
        </ul>


        <h1>파일</h1>
        <h2>파일에 문자열 쓰기/읽기</h2>
        <p><span id="accent">fopen → 쓰기/읽기함수 → fclose</span></p>
        <ul><span id="ulh">fopen</span>
          <li><span id="accent">FILE *파일포인터 = fopen(파일명, 파일모드);</span> 성공하면 파일 포인터를 반환, 실패하면 NULL을 반환</li>
          <li>fopen 함수에 파일명만 지정하면 현재 작업 디렉토리에서 파일을 연다. 파일명앞에 경로를 추가할 수 있다.</li>
        </ul>
        <ul><span id="ulh">쓰기함수</span>
          <li><span id="accent">fprintf(파일포인터, 서식, 값1, 값2, ...);
            </span> 성공_문자열길이반환/실패_음수반환</li>
          <li><span id="accent">fputs(문자열, 파일포인터);
            </span> 성공_음수가아닌값/실패_EOF(-1)</li>
          <li><span id="accent">fwrite(문자열, 문자열길이, 쓰기횟수, 파일포인터);
            </span> 성공_쓰기횟수/실패_지정된 쓰기횟수보다 작은값</li>
          <li><span id="comment">파일포인터 대신 표준출력(stdout)을 지정하면 문자열이 화면에 출력됩니다.</span></li>
        </ul>
        <ul><span id="ulh">읽기함수</span>
          <li><span id="accent">fscanf(파일포인터, 서식, 변수의주소1, 변수의주소2, …);
            </span> 성공_읽어온값개수/실패_EOF(-1)</li>
          <li><span id="accent">버퍼선언; fgets(버퍼, 버퍼크기, 파일포인터);
            </span> 성공_읽은문자열포인터/실패_NULL <br>버퍼크기만큼만읽고, 줄바꿈뒤는읽어오지않음</li>
          <li><span id="accent">버퍼초기화선언; fread(버퍼, 버퍼크기, 읽기횟수, 파일포인터);
            </span> 성공_읽기횟수/실패_ 지정된 읽기횟수보다 작은값<br>줄바꿈도읽어옴 </li>
          <li><span id="comment">파일포인터 대신 표준입력(stdin)을 지정하면 문자열이 화면에 입력됩니다.</span></li>
        </ul>

        <ul><span id="ulh">fclose</span>
          <li><span id="accent">fclose(파일포인터);</span> 성공하면 0을 반환, 실패하면 EOF(-1)를 반환</li>
          <li>파일 포인터 fp도 구조체 FILE 크기만큼 동적 메모리를 할당한 것이기 때문에 fclose 함수로 닫아주지 않으면 메모리 누수가 발생</li>
        </ul>

        <table border="1">
          <thead>
            <tr>
              <th>파일<br>모드</th>
              <th>기능</th>
              <th>설명</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>"r"</td>
              <td>읽기</td>
              <td>파일을 읽기전용으로 엽니다.<br>파일이 반드시 있어야 가능</td>
            </tr>
            <tr>
              <td>"w"</td>
              <td>쓰기</td>
              <td>새 파일을 생성합니다.<br>만약 파일이 있으면 내용을 덮어씁니다.</td>
            </tr>
            <tr>
              <td>"a"</td>
              <td>추가</td>
              <td>파일을 열어 파일 끝에 값을 이어 씁니다.<br>만약 파일이 없으면 파일을 생성합니다.</td>
            </tr>
            <tr>
              <td>"r+"</td>
              <td>읽기<br>쓰기</td>
              <td>파일을 읽기/쓰기용으로 엽니다.<br>단, 파일이 반드시 있어야 하며 파일이 없으면 NULL을 반환</td>
            </tr>
            <tr>
              <td>"w+"</td>
              <td>읽기<br>쓰기</td>
              <td>파일을 읽기/쓰기용으로 엽니다.<br>파일이 없으면 파일을 생성하고, 파일이 있으면 내용을 덮어씁니다.</td>
            </tr>
            <tr>
              <td>"a+"</td>
              <td>추가<br>읽기<br>쓰기</td>
              <td>파일을 열어 파일 끝에 값을 이어 씁니다.<br>만약 파일이 없으면 파일을 생성합니다. <br>읽기는 파일의 모든 구간에서 가능하지만, 쓰기는 파일의 끝에서만 가능합니다.</td>
            </tr>
            <thead>
              <tr>
                <th>옵션</th>
                <th></th>
                <th>단독사용불가</th>
              </tr>
            </thead>
            <tr>
              <td>t</td>
              <td>텍스트<br>모드</td>
              <td>파일을 읽거나 쓸 때 개행문자 \n와 \r\n을 서로 변환합니다.<br>^Z 파일의 끝으로 인식하므로 ^Z까지만 파일을 읽습니다(^Z는 Ctrl+Z 입력을 뜻합니다).</td>
            </tr>
            <tr>
              <td>b</td>
              <td>바이너리<br>모드</td>
              <td>파일의 내용을 그대로 읽고, 값을 그대로 씁니다.</td>
            </tr>
          </tbody>
        </table>


    </div>
  </div>
</body>

</html>